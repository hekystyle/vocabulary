{"version":3,"file":"static/js/604.af93987f.chunk.js","mappings":"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","sources":["../node_modules/src/decorators/type.decorator.ts","../node_modules/src/enums/transformation-type.enum.ts","../node_modules/src/TransformOperationExecutor.ts","../node_modules/src/utils/is-promise.util.ts","../node_modules/src/utils/get-global.util.ts","../node_modules/src/constants/default-options.constant.ts","../node_modules/src/index.ts","../node_modules/src/ClassTransformer.ts","../node_modules/src/storage.ts","../node_modules/src/MetadataStorage.ts","../node_modules/src/container.ts","../node_modules/src/decorator/common/IsDefined.ts","../node_modules/src/metadata/ConstraintMetadata.ts","../node_modules/src/decorator/common/ValidateBy.ts","../node_modules/src/register-decorator.ts","../node_modules/src/decorator/common/ValidateNested.ts","../node_modules/src/decorator/string/IsUrl.ts","../node_modules/src/decorator/typechecker/IsArray.ts","../node_modules/src/decorator/typechecker/IsString.ts","../node_modules/src/validation/ValidationError.ts","../node_modules/src/validation/ValidationUtils.ts","../node_modules/src/validation/ValidationExecutor.ts","../node_modules/src/utils/convert-to-array.util.ts","../node_modules/src/validation/Validator.ts","../node_modules/src/validation-schema/ValidationSchemaToMetadataTransformer.ts","../node_modules/src/metadata/MetadataStorage.ts","../node_modules/src/metadata/ValidationMetadata.ts","../node_modules/src/validation/ValidationTypes.ts","../node_modules/validator/lib/isFQDN.js","../node_modules/validator/lib/isIP.js","../node_modules/validator/lib/isURL.js","../node_modules/validator/lib/util/assertString.js","../node_modules/validator/lib/util/merge.js","../node_modules/@babel/runtime/helpers/esm/applyDecoratedDescriptor.js","../node_modules/@babel/runtime/helpers/esm/initializerDefineProperty.js"],"sourcesContent":["import { defaultMetadataStorage } from '../storage';\nimport { TypeHelpOptions, TypeOptions } from '../interfaces';\n\n/**\n * Specifies a type of the property.\n * The given TypeFunction can return a constructor. A discriminator can be given in the options.\n *\n * Can be applied to properties only.\n */\nexport function Type(\n  typeFunction?: (type?: TypeHelpOptions) => Function,\n  options: TypeOptions = {}\n): PropertyDecorator {\n  return function (target: any, propertyName: string | Symbol): void {\n    const reflectedType = (Reflect as any).getMetadata('design:type', target, propertyName);\n    defaultMetadataStorage.addTypeMetadata({\n      target: target.constructor,\n      propertyName: propertyName as string,\n      reflectedType,\n      typeFunction,\n      options,\n    });\n  };\n}\n","export enum TransformationType {\n  PLAIN_TO_CLASS,\n  CLASS_TO_PLAIN,\n  CLASS_TO_CLASS,\n}\n","import { defaultMetadataStorage } from './storage';\nimport { ClassTransformOptions, TypeHelpOptions, TypeMetadata, TypeOptions } from './interfaces';\nimport { TransformationType } from './enums';\nimport { getGlobal, isPromise } from './utils';\n\nfunction instantiateArrayType(arrayType: Function): Array<any> | Set<any> {\n  const array = new (arrayType as any)();\n  if (!(array instanceof Set) && !('push' in array)) {\n    return [];\n  }\n  return array;\n}\n\nexport class TransformOperationExecutor {\n  // -------------------------------------------------------------------------\n  // Private Properties\n  // -------------------------------------------------------------------------\n\n  private recursionStack = new Set<Record<string, any>>();\n\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n\n  constructor(private transformationType: TransformationType, private options: ClassTransformOptions) {}\n\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  transform(\n    source: Record<string, any> | Record<string, any>[] | any,\n    value: Record<string, any> | Record<string, any>[] | any,\n    targetType: Function | TypeMetadata,\n    arrayType: Function,\n    isMap: boolean,\n    level: number = 0\n  ): any {\n    if (Array.isArray(value) || value instanceof Set) {\n      const newValue =\n        arrayType && this.transformationType === TransformationType.PLAIN_TO_CLASS\n          ? instantiateArrayType(arrayType)\n          : [];\n      (value as any[]).forEach((subValue, index) => {\n        const subSource = source ? source[index] : undefined;\n        if (!this.options.enableCircularCheck || !this.isCircular(subValue)) {\n          let realTargetType;\n          if (\n            typeof targetType !== 'function' &&\n            targetType &&\n            targetType.options &&\n            targetType.options.discriminator &&\n            targetType.options.discriminator.property &&\n            targetType.options.discriminator.subTypes\n          ) {\n            if (this.transformationType === TransformationType.PLAIN_TO_CLASS) {\n              realTargetType = targetType.options.discriminator.subTypes.find(\n                subType =>\n                  subType.name === subValue[(targetType as { options: TypeOptions }).options.discriminator.property]\n              );\n              const options: TypeHelpOptions = { newObject: newValue, object: subValue, property: undefined };\n              const newType = targetType.typeFunction(options);\n              realTargetType === undefined ? (realTargetType = newType) : (realTargetType = realTargetType.value);\n              if (!targetType.options.keepDiscriminatorProperty)\n                delete subValue[targetType.options.discriminator.property];\n            }\n\n            if (this.transformationType === TransformationType.CLASS_TO_CLASS) {\n              realTargetType = subValue.constructor;\n            }\n            if (this.transformationType === TransformationType.CLASS_TO_PLAIN) {\n              subValue[targetType.options.discriminator.property] = targetType.options.discriminator.subTypes.find(\n                subType => subType.value === subValue.constructor\n              ).name;\n            }\n          } else {\n            realTargetType = targetType;\n          }\n          const value = this.transform(\n            subSource,\n            subValue,\n            realTargetType,\n            undefined,\n            subValue instanceof Map,\n            level + 1\n          );\n\n          if (newValue instanceof Set) {\n            newValue.add(value);\n          } else {\n            newValue.push(value);\n          }\n        } else if (this.transformationType === TransformationType.CLASS_TO_CLASS) {\n          if (newValue instanceof Set) {\n            newValue.add(subValue);\n          } else {\n            newValue.push(subValue);\n          }\n        }\n      });\n      return newValue;\n    } else if (targetType === String && !isMap) {\n      if (value === null || value === undefined) return value;\n      return String(value);\n    } else if (targetType === Number && !isMap) {\n      if (value === null || value === undefined) return value;\n      return Number(value);\n    } else if (targetType === Boolean && !isMap) {\n      if (value === null || value === undefined) return value;\n      return Boolean(value);\n    } else if ((targetType === Date || value instanceof Date) && !isMap) {\n      if (value instanceof Date) {\n        return new Date(value.valueOf());\n      }\n      if (value === null || value === undefined) return value;\n      return new Date(value);\n    } else if (!!getGlobal().Buffer && (targetType === Buffer || value instanceof Buffer) && !isMap) {\n      if (value === null || value === undefined) return value;\n      return Buffer.from(value);\n    } else if (isPromise(value) && !isMap) {\n      return new Promise((resolve, reject) => {\n        value.then(\n          (data: any) => resolve(this.transform(undefined, data, targetType, undefined, undefined, level + 1)),\n          reject\n        );\n      });\n    } else if (!isMap && value !== null && typeof value === 'object' && typeof value.then === 'function') {\n      // Note: We should not enter this, as promise has been handled above\n      // This option simply returns the Promise preventing a JS error from happening and should be an inaccessible path.\n      return value; // skip promise transformation\n    } else if (typeof value === 'object' && value !== null) {\n      // try to guess the type\n      if (!targetType && value.constructor !== Object /* && TransformationType === TransformationType.CLASS_TO_PLAIN*/)\n        if (!Array.isArray(value) && value.constructor === Array) {\n          // Somebody attempts to convert special Array like object to Array, eg:\n          // const evilObject = { '100000000': '100000000', __proto__: [] };\n          // This could be used to cause Denial-of-service attack so we don't allow it.\n          // See prevent-array-bomb.spec.ts for more details.\n        } else {\n          // We are good we can use the built-in constructor\n          targetType = value.constructor;\n        }\n      if (!targetType && source) targetType = source.constructor;\n\n      if (this.options.enableCircularCheck) {\n        // add transformed type to prevent circular references\n        this.recursionStack.add(value);\n      }\n\n      const keys = this.getKeys(targetType as Function, value, isMap);\n      let newValue: any = source ? source : {};\n      if (\n        !source &&\n        (this.transformationType === TransformationType.PLAIN_TO_CLASS ||\n          this.transformationType === TransformationType.CLASS_TO_CLASS)\n      ) {\n        if (isMap) {\n          newValue = new Map();\n        } else if (targetType) {\n          newValue = new (targetType as any)();\n        } else {\n          newValue = {};\n        }\n      }\n\n      // traverse over keys\n      for (const key of keys) {\n        if (key === '__proto__' || key === 'constructor') {\n          continue;\n        }\n\n        const valueKey = key;\n        let newValueKey = key,\n          propertyName = key;\n        if (!this.options.ignoreDecorators && targetType) {\n          if (this.transformationType === TransformationType.PLAIN_TO_CLASS) {\n            const exposeMetadata = defaultMetadataStorage.findExposeMetadataByCustomName(targetType as Function, key);\n            if (exposeMetadata) {\n              propertyName = exposeMetadata.propertyName;\n              newValueKey = exposeMetadata.propertyName;\n            }\n          } else if (\n            this.transformationType === TransformationType.CLASS_TO_PLAIN ||\n            this.transformationType === TransformationType.CLASS_TO_CLASS\n          ) {\n            const exposeMetadata = defaultMetadataStorage.findExposeMetadata(targetType as Function, key);\n            if (exposeMetadata && exposeMetadata.options && exposeMetadata.options.name) {\n              newValueKey = exposeMetadata.options.name;\n            }\n          }\n        }\n\n        // get a subvalue\n        let subValue: any = undefined;\n        if (this.transformationType === TransformationType.PLAIN_TO_CLASS) {\n          /**\n           * This section is added for the following report:\n           * https://github.com/typestack/class-transformer/issues/596\n           *\n           * We should not call functions or constructors when transforming to class.\n           */\n          subValue = value[valueKey];\n        } else {\n          if (value instanceof Map) {\n            subValue = value.get(valueKey);\n          } else if (value[valueKey] instanceof Function) {\n            subValue = value[valueKey]();\n          } else {\n            subValue = value[valueKey];\n          }\n        }\n\n        // determine a type\n        let type: any = undefined,\n          isSubValueMap = subValue instanceof Map;\n        if (targetType && isMap) {\n          type = targetType;\n        } else if (targetType) {\n          const metadata = defaultMetadataStorage.findTypeMetadata(targetType as Function, propertyName);\n          if (metadata) {\n            const options: TypeHelpOptions = { newObject: newValue, object: value, property: propertyName };\n            const newType = metadata.typeFunction ? metadata.typeFunction(options) : metadata.reflectedType;\n            if (\n              metadata.options &&\n              metadata.options.discriminator &&\n              metadata.options.discriminator.property &&\n              metadata.options.discriminator.subTypes\n            ) {\n              if (!(value[valueKey] instanceof Array)) {\n                if (this.transformationType === TransformationType.PLAIN_TO_CLASS) {\n                  type = metadata.options.discriminator.subTypes.find(subType => {\n                    if (subValue && subValue instanceof Object && metadata.options.discriminator.property in subValue) {\n                      return subType.name === subValue[metadata.options.discriminator.property];\n                    }\n                  });\n                  type === undefined ? (type = newType) : (type = type.value);\n                  if (!metadata.options.keepDiscriminatorProperty) {\n                    if (subValue && subValue instanceof Object && metadata.options.discriminator.property in subValue) {\n                      delete subValue[metadata.options.discriminator.property];\n                    }\n                  }\n                }\n                if (this.transformationType === TransformationType.CLASS_TO_CLASS) {\n                  type = subValue.constructor;\n                }\n                if (this.transformationType === TransformationType.CLASS_TO_PLAIN) {\n                  if (subValue) {\n                    subValue[metadata.options.discriminator.property] = metadata.options.discriminator.subTypes.find(\n                      subType => subType.value === subValue.constructor\n                    ).name;\n                  }\n                }\n              } else {\n                type = metadata;\n              }\n            } else {\n              type = newType;\n            }\n            isSubValueMap = isSubValueMap || metadata.reflectedType === Map;\n          } else if (this.options.targetMaps) {\n            // try to find a type in target maps\n            this.options.targetMaps\n              .filter(map => map.target === targetType && !!map.properties[propertyName])\n              .forEach(map => (type = map.properties[propertyName]));\n          } else if (\n            this.options.enableImplicitConversion &&\n            this.transformationType === TransformationType.PLAIN_TO_CLASS\n          ) {\n            // if we have no registererd type via the @Type() decorator then we check if we have any\n            // type declarations in reflect-metadata (type declaration is emited only if some decorator is added to the property.)\n            const reflectedType = (Reflect as any).getMetadata(\n              'design:type',\n              (targetType as Function).prototype,\n              propertyName\n            );\n\n            if (reflectedType) {\n              type = reflectedType;\n            }\n          }\n        }\n\n        // if value is an array try to get its custom array type\n        const arrayType = Array.isArray(value[valueKey])\n          ? this.getReflectedType(targetType as Function, propertyName)\n          : undefined;\n\n        // const subValueKey = TransformationType === TransformationType.PLAIN_TO_CLASS && newKeyName ? newKeyName : key;\n        const subSource = source ? source[valueKey] : undefined;\n\n        // if its deserialization then type if required\n        // if we uncomment this types like string[] will not work\n        // if (this.transformationType === TransformationType.PLAIN_TO_CLASS && !type && subValue instanceof Object && !(subValue instanceof Date))\n        //     throw new Error(`Cannot determine type for ${(targetType as any).name }.${propertyName}, did you forget to specify a @Type?`);\n\n        // if newValue is a source object that has method that match newKeyName then skip it\n        if (newValue.constructor.prototype) {\n          const descriptor = Object.getOwnPropertyDescriptor(newValue.constructor.prototype, newValueKey);\n          if (\n            (this.transformationType === TransformationType.PLAIN_TO_CLASS ||\n              this.transformationType === TransformationType.CLASS_TO_CLASS) &&\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            ((descriptor && !descriptor.set) || newValue[newValueKey] instanceof Function)\n          )\n            //  || TransformationType === TransformationType.CLASS_TO_CLASS\n            continue;\n        }\n\n        if (!this.options.enableCircularCheck || !this.isCircular(subValue)) {\n          const transformKey = this.transformationType === TransformationType.PLAIN_TO_CLASS ? newValueKey : key;\n          let finalValue;\n\n          if (this.transformationType === TransformationType.CLASS_TO_PLAIN) {\n            // Get original value\n            finalValue = value[transformKey];\n            // Apply custom transformation\n            finalValue = this.applyCustomTransformations(\n              finalValue,\n              targetType as Function,\n              transformKey,\n              value,\n              this.transformationType\n            );\n            // If nothing change, it means no custom transformation was applied, so use the subValue.\n            finalValue = value[transformKey] === finalValue ? subValue : finalValue;\n            // Apply the default transformation\n            finalValue = this.transform(subSource, finalValue, type, arrayType, isSubValueMap, level + 1);\n          } else {\n            if (subValue === undefined && this.options.exposeDefaultValues) {\n              // Set default value if nothing provided\n              finalValue = newValue[newValueKey];\n            } else {\n              finalValue = this.transform(subSource, subValue, type, arrayType, isSubValueMap, level + 1);\n              finalValue = this.applyCustomTransformations(\n                finalValue,\n                targetType as Function,\n                transformKey,\n                value,\n                this.transformationType\n              );\n            }\n          }\n\n          if (finalValue !== undefined || this.options.exposeUnsetFields) {\n            if (newValue instanceof Map) {\n              newValue.set(newValueKey, finalValue);\n            } else {\n              newValue[newValueKey] = finalValue;\n            }\n          }\n        } else if (this.transformationType === TransformationType.CLASS_TO_CLASS) {\n          let finalValue = subValue;\n          finalValue = this.applyCustomTransformations(\n            finalValue,\n            targetType as Function,\n            key,\n            value,\n            this.transformationType\n          );\n          if (finalValue !== undefined || this.options.exposeUnsetFields) {\n            if (newValue instanceof Map) {\n              newValue.set(newValueKey, finalValue);\n            } else {\n              newValue[newValueKey] = finalValue;\n            }\n          }\n        }\n      }\n\n      if (this.options.enableCircularCheck) {\n        this.recursionStack.delete(value);\n      }\n\n      return newValue;\n    } else {\n      return value;\n    }\n  }\n\n  private applyCustomTransformations(\n    value: any,\n    target: Function,\n    key: string,\n    obj: any,\n    transformationType: TransformationType\n  ): boolean {\n    let metadatas = defaultMetadataStorage.findTransformMetadatas(target, key, this.transformationType);\n\n    // apply versioning options\n    if (this.options.version !== undefined) {\n      metadatas = metadatas.filter(metadata => {\n        if (!metadata.options) return true;\n\n        return this.checkVersion(metadata.options.since, metadata.options.until);\n      });\n    }\n\n    // apply grouping options\n    if (this.options.groups && this.options.groups.length) {\n      metadatas = metadatas.filter(metadata => {\n        if (!metadata.options) return true;\n\n        return this.checkGroups(metadata.options.groups);\n      });\n    } else {\n      metadatas = metadatas.filter(metadata => {\n        return !metadata.options || !metadata.options.groups || !metadata.options.groups.length;\n      });\n    }\n\n    metadatas.forEach(metadata => {\n      value = metadata.transformFn({ value, key, obj, type: transformationType, options: this.options });\n    });\n\n    return value;\n  }\n\n  // preventing circular references\n  private isCircular(object: Record<string, any>): boolean {\n    return this.recursionStack.has(object);\n  }\n\n  private getReflectedType(target: Function, propertyName: string): Function | undefined {\n    if (!target) return undefined;\n    const meta = defaultMetadataStorage.findTypeMetadata(target, propertyName);\n    return meta ? meta.reflectedType : undefined;\n  }\n\n  private getKeys(target: Function, object: Record<string, any>, isMap: boolean): string[] {\n    // determine exclusion strategy\n    let strategy = defaultMetadataStorage.getStrategy(target);\n    if (strategy === 'none') strategy = this.options.strategy || 'exposeAll'; // exposeAll is default strategy\n\n    // get all keys that need to expose\n    let keys: any[] = [];\n    if (strategy === 'exposeAll' || isMap) {\n      if (object instanceof Map) {\n        keys = Array.from(object.keys());\n      } else {\n        keys = Object.keys(object);\n      }\n    }\n\n    if (isMap) {\n      // expose & exclude do not apply for map keys only to fields\n      return keys;\n    }\n\n    /**\n     * If decorators are ignored but we don't want the extraneous values, then we use the\n     * metadata to decide which property is needed, but doesn't apply the decorator effect.\n     */\n    if (this.options.ignoreDecorators && this.options.excludeExtraneousValues && target) {\n      const exposedProperties = defaultMetadataStorage.getExposedProperties(target, this.transformationType);\n      const excludedProperties = defaultMetadataStorage.getExcludedProperties(target, this.transformationType);\n      keys = [...exposedProperties, ...excludedProperties];\n    }\n\n    if (!this.options.ignoreDecorators && target) {\n      // add all exposed to list of keys\n      let exposedProperties = defaultMetadataStorage.getExposedProperties(target, this.transformationType);\n      if (this.transformationType === TransformationType.PLAIN_TO_CLASS) {\n        exposedProperties = exposedProperties.map(key => {\n          const exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);\n          if (exposeMetadata && exposeMetadata.options && exposeMetadata.options.name) {\n            return exposeMetadata.options.name;\n          }\n\n          return key;\n        });\n      }\n      if (this.options.excludeExtraneousValues) {\n        keys = exposedProperties;\n      } else {\n        keys = keys.concat(exposedProperties);\n      }\n\n      // exclude excluded properties\n      const excludedProperties = defaultMetadataStorage.getExcludedProperties(target, this.transformationType);\n      if (excludedProperties.length > 0) {\n        keys = keys.filter(key => {\n          return !excludedProperties.includes(key);\n        });\n      }\n\n      // apply versioning options\n      if (this.options.version !== undefined) {\n        keys = keys.filter(key => {\n          const exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);\n          if (!exposeMetadata || !exposeMetadata.options) return true;\n\n          return this.checkVersion(exposeMetadata.options.since, exposeMetadata.options.until);\n        });\n      }\n\n      // apply grouping options\n      if (this.options.groups && this.options.groups.length) {\n        keys = keys.filter(key => {\n          const exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);\n          if (!exposeMetadata || !exposeMetadata.options) return true;\n\n          return this.checkGroups(exposeMetadata.options.groups);\n        });\n      } else {\n        keys = keys.filter(key => {\n          const exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);\n          return (\n            !exposeMetadata ||\n            !exposeMetadata.options ||\n            !exposeMetadata.options.groups ||\n            !exposeMetadata.options.groups.length\n          );\n        });\n      }\n    }\n\n    // exclude prefixed properties\n    if (this.options.excludePrefixes && this.options.excludePrefixes.length) {\n      keys = keys.filter(key =>\n        this.options.excludePrefixes.every(prefix => {\n          return key.substr(0, prefix.length) !== prefix;\n        })\n      );\n    }\n\n    // make sure we have unique keys\n    keys = keys.filter((key, index, self) => {\n      return self.indexOf(key) === index;\n    });\n\n    return keys;\n  }\n\n  private checkVersion(since: number, until: number): boolean {\n    let decision = true;\n    if (decision && since) decision = this.options.version >= since;\n    if (decision && until) decision = this.options.version < until;\n\n    return decision;\n  }\n\n  private checkGroups(groups: string[]): boolean {\n    if (!groups) return true;\n\n    return this.options.groups.some(optionGroup => groups.includes(optionGroup));\n  }\n}\n","export function isPromise<T>(p: any): p is Promise<T> {\n  return p !== null && typeof p === 'object' && typeof p.then === 'function';\n}\n","/**\n * This function returns the global object across Node and browsers.\n *\n * Note: `globalThis` is the standardized approach however it has been added to\n * Node.js in version 12. We need to include this snippet until Node 12 EOL.\n */\nexport function getGlobal() {\n  if (typeof globalThis !== 'undefined') {\n    return globalThis;\n  }\n\n  if (typeof global !== 'undefined') {\n    return global;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore: Cannot find name 'window'.\n  if (typeof window !== 'undefined') {\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore: Cannot find name 'window'.\n    return window;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore: Cannot find name 'self'.\n  if (typeof self !== 'undefined') {\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore: Cannot find name 'self'.\n    return self;\n  }\n}\n","import { ClassTransformOptions } from '../interfaces/class-transformer-options.interface';\n\n/**\n * These are the default options used by any transformation operation.\n */\nexport const defaultOptions: Partial<ClassTransformOptions> = {\n  enableCircularCheck: false,\n  enableImplicitConversion: false,\n  excludeExtraneousValues: false,\n  excludePrefixes: undefined,\n  exposeDefaultValues: false,\n  exposeUnsetFields: true,\n  groups: undefined,\n  ignoreDecorators: false,\n  strategy: undefined,\n  targetMaps: undefined,\n  version: undefined,\n};\n","import { ClassTransformer } from './ClassTransformer';\nimport { ClassTransformOptions } from './interfaces';\nimport { ClassConstructor } from './interfaces';\n\nexport { ClassTransformer } from './ClassTransformer';\nexport * from './decorators';\nexport * from './interfaces';\nexport * from './enums';\n\nconst classTransformer = new ClassTransformer();\n\n/**\n * Converts class (constructor) object to plain (literal) object. Also works with arrays.\n *\n * @deprecated Function name changed, use the `instanceToPlain` method instead.\n */\nexport function classToPlain<T>(object: T, options?: ClassTransformOptions): Record<string, any>;\nexport function classToPlain<T>(object: T[], options?: ClassTransformOptions): Record<string, any>[];\nexport function classToPlain<T>(\n  object: T | T[],\n  options?: ClassTransformOptions\n): Record<string, any> | Record<string, any>[] {\n  return classTransformer.instanceToPlain(object, options);\n}\n\n/**\n * Converts class (constructor) object to plain (literal) object. Also works with arrays.\n */\nexport function instanceToPlain<T>(object: T, options?: ClassTransformOptions): Record<string, any>;\nexport function instanceToPlain<T>(object: T[], options?: ClassTransformOptions): Record<string, any>[];\nexport function instanceToPlain<T>(\n  object: T | T[],\n  options?: ClassTransformOptions\n): Record<string, any> | Record<string, any>[] {\n  return classTransformer.instanceToPlain(object, options);\n}\n\n/**\n * Converts class (constructor) object to plain (literal) object.\n * Uses given plain object as source object (it means fills given plain object with data from class object).\n * Also works with arrays.\n *\n * @deprecated This function is being removed.\n */\nexport function classToPlainFromExist<T>(\n  object: T,\n  plainObject: Record<string, any>,\n  options?: ClassTransformOptions\n): Record<string, any>;\nexport function classToPlainFromExist<T>(\n  object: T,\n  plainObjects: Record<string, any>[],\n  options?: ClassTransformOptions\n): Record<string, any>[];\nexport function classToPlainFromExist<T>(\n  object: T,\n  plainObject: Record<string, any> | Record<string, any>[],\n  options?: ClassTransformOptions\n): Record<string, any> | Record<string, any>[] {\n  return classTransformer.classToPlainFromExist(object, plainObject, options);\n}\n\n/**\n * Converts plain (literal) object to class (constructor) object. Also works with arrays.\n *\n * @deprecated Function name changed, use the `plainToInstance` method instead.\n */\nexport function plainToClass<T, V>(cls: ClassConstructor<T>, plain: V[], options?: ClassTransformOptions): T[];\nexport function plainToClass<T, V>(cls: ClassConstructor<T>, plain: V, options?: ClassTransformOptions): T;\nexport function plainToClass<T, V>(cls: ClassConstructor<T>, plain: V | V[], options?: ClassTransformOptions): T | T[] {\n  return classTransformer.plainToInstance(cls, plain as any, options);\n}\n\n/**\n * Converts plain (literal) object to class (constructor) object. Also works with arrays.\n */\nexport function plainToInstance<T, V>(cls: ClassConstructor<T>, plain: V[], options?: ClassTransformOptions): T[];\nexport function plainToInstance<T, V>(cls: ClassConstructor<T>, plain: V, options?: ClassTransformOptions): T;\nexport function plainToInstance<T, V>(\n  cls: ClassConstructor<T>,\n  plain: V | V[],\n  options?: ClassTransformOptions\n): T | T[] {\n  return classTransformer.plainToInstance(cls, plain as any, options);\n}\n\n/**\n * Converts plain (literal) object to class (constructor) object.\n * Uses given object as source object (it means fills given object with data from plain object).\n *  Also works with arrays.\n *\n * @deprecated This function is being removed. The current implementation is incorrect as it modifies the source object.\n */\nexport function plainToClassFromExist<T, V>(clsObject: T[], plain: V[], options?: ClassTransformOptions): T[];\nexport function plainToClassFromExist<T, V>(clsObject: T, plain: V, options?: ClassTransformOptions): T;\nexport function plainToClassFromExist<T, V>(clsObject: T, plain: V | V[], options?: ClassTransformOptions): T | T[] {\n  return classTransformer.plainToClassFromExist(clsObject, plain, options);\n}\n\n/**\n * Converts class (constructor) object to new class (constructor) object. Also works with arrays.\n */\nexport function instanceToInstance<T>(object: T, options?: ClassTransformOptions): T;\nexport function instanceToInstance<T>(object: T[], options?: ClassTransformOptions): T[];\nexport function instanceToInstance<T>(object: T | T[], options?: ClassTransformOptions): T | T[] {\n  return classTransformer.instanceToInstance(object, options);\n}\n\n/**\n * Converts class (constructor) object to plain (literal) object.\n * Uses given plain object as source object (it means fills given plain object with data from class object).\n * Also works with arrays.\n *\n * @deprecated This function is being removed. The current implementation is incorrect as it modifies the source object.\n */\nexport function classToClassFromExist<T>(object: T, fromObject: T, options?: ClassTransformOptions): T;\nexport function classToClassFromExist<T>(object: T, fromObjects: T[], options?: ClassTransformOptions): T[];\nexport function classToClassFromExist<T>(object: T, fromObject: T | T[], options?: ClassTransformOptions): T | T[] {\n  return classTransformer.classToClassFromExist(object, fromObject, options);\n}\n\n/**\n * Serializes given object to a JSON string.\n *\n * @deprecated This function is being removed. Please use\n * ```\n * JSON.stringify(instanceToPlain(object, options))\n * ```\n */\nexport function serialize<T>(object: T, options?: ClassTransformOptions): string;\nexport function serialize<T>(object: T[], options?: ClassTransformOptions): string;\nexport function serialize<T>(object: T | T[], options?: ClassTransformOptions): string {\n  return classTransformer.serialize(object, options);\n}\n\n/**\n * Deserializes given JSON string to a object of the given class.\n *\n * @deprecated This function is being removed. Please use the following instead:\n * ```\n * instanceToClass(cls, JSON.parse(json), options)\n * ```\n */\nexport function deserialize<T>(cls: ClassConstructor<T>, json: string, options?: ClassTransformOptions): T {\n  return classTransformer.deserialize(cls, json, options);\n}\n\n/**\n * Deserializes given JSON string to an array of objects of the given class.\n *\n * @deprecated This function is being removed. Please use the following instead:\n * ```\n * JSON.parse(json).map(value => instanceToClass(cls, value, options))\n * ```\n *\n */\nexport function deserializeArray<T>(cls: ClassConstructor<T>, json: string, options?: ClassTransformOptions): T[] {\n  return classTransformer.deserializeArray(cls, json, options);\n}\n","import { ClassTransformOptions } from './interfaces';\nimport { TransformOperationExecutor } from './TransformOperationExecutor';\nimport { TransformationType } from './enums';\nimport { ClassConstructor } from './interfaces';\nimport { defaultOptions } from './constants/default-options.constant';\n\nexport class ClassTransformer {\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Converts class (constructor) object to plain (literal) object. Also works with arrays.\n   */\n  instanceToPlain<T extends Record<string, any>>(object: T, options?: ClassTransformOptions): Record<string, any>;\n  instanceToPlain<T extends Record<string, any>>(object: T[], options?: ClassTransformOptions): Record<string, any>[];\n  instanceToPlain<T extends Record<string, any>>(\n    object: T | T[],\n    options?: ClassTransformOptions\n  ): Record<string, any> | Record<string, any>[] {\n    const executor = new TransformOperationExecutor(TransformationType.CLASS_TO_PLAIN, {\n      ...defaultOptions,\n      ...options,\n    });\n    return executor.transform(undefined, object, undefined, undefined, undefined, undefined);\n  }\n\n  /**\n   * Converts class (constructor) object to plain (literal) object.\n   * Uses given plain object as source object (it means fills given plain object with data from class object).\n   * Also works with arrays.\n   */\n  classToPlainFromExist<T extends Record<string, any>, P>(\n    object: T,\n    plainObject: P,\n    options?: ClassTransformOptions\n  ): T;\n  classToPlainFromExist<T extends Record<string, any>, P>(\n    object: T,\n    plainObjects: P[],\n    options?: ClassTransformOptions\n  ): T[];\n  classToPlainFromExist<T extends Record<string, any>, P>(\n    object: T,\n    plainObject: P | P[],\n    options?: ClassTransformOptions\n  ): T | T[] {\n    const executor = new TransformOperationExecutor(TransformationType.CLASS_TO_PLAIN, {\n      ...defaultOptions,\n      ...options,\n    });\n    return executor.transform(plainObject, object, undefined, undefined, undefined, undefined);\n  }\n\n  /**\n   * Converts plain (literal) object to class (constructor) object. Also works with arrays.\n   */\n  plainToInstance<T extends Record<string, any>, V extends Array<any>>(\n    cls: ClassConstructor<T>,\n    plain: V,\n    options?: ClassTransformOptions\n  ): T[];\n  plainToInstance<T extends Record<string, any>, V>(\n    cls: ClassConstructor<T>,\n    plain: V,\n    options?: ClassTransformOptions\n  ): T;\n  plainToInstance<T extends Record<string, any>, V>(\n    cls: ClassConstructor<T>,\n    plain: V | V[],\n    options?: ClassTransformOptions\n  ): T | T[] {\n    const executor = new TransformOperationExecutor(TransformationType.PLAIN_TO_CLASS, {\n      ...defaultOptions,\n      ...options,\n    });\n    return executor.transform(undefined, plain, cls, undefined, undefined, undefined);\n  }\n\n  /**\n   * Converts plain (literal) object to class (constructor) object.\n   * Uses given object as source object (it means fills given object with data from plain object).\n   * Also works with arrays.\n   */\n  plainToClassFromExist<T extends Record<string, any>, V extends Array<any>>(\n    clsObject: T,\n    plain: V,\n    options?: ClassTransformOptions\n  ): T;\n  plainToClassFromExist<T extends Record<string, any>, V>(clsObject: T, plain: V, options?: ClassTransformOptions): T[];\n  plainToClassFromExist<T extends Record<string, any>, V>(\n    clsObject: T,\n    plain: V | V[],\n    options?: ClassTransformOptions\n  ): T | T[] {\n    const executor = new TransformOperationExecutor(TransformationType.PLAIN_TO_CLASS, {\n      ...defaultOptions,\n      ...options,\n    });\n    return executor.transform(clsObject, plain, undefined, undefined, undefined, undefined);\n  }\n\n  /**\n   * Converts class (constructor) object to new class (constructor) object. Also works with arrays.\n   */\n  instanceToInstance<T>(object: T, options?: ClassTransformOptions): T;\n  instanceToInstance<T>(object: T[], options?: ClassTransformOptions): T[];\n  instanceToInstance<T>(object: T | T[], options?: ClassTransformOptions): T | T[] {\n    const executor = new TransformOperationExecutor(TransformationType.CLASS_TO_CLASS, {\n      ...defaultOptions,\n      ...options,\n    });\n    return executor.transform(undefined, object, undefined, undefined, undefined, undefined);\n  }\n\n  /**\n   * Converts class (constructor) object to plain (literal) object.\n   * Uses given plain object as source object (it means fills given plain object with data from class object).\n   * Also works with arrays.\n   */\n  classToClassFromExist<T>(object: T, fromObject: T, options?: ClassTransformOptions): T;\n  classToClassFromExist<T>(object: T, fromObjects: T[], options?: ClassTransformOptions): T[];\n  classToClassFromExist<T>(object: T, fromObject: T | T[], options?: ClassTransformOptions): T | T[] {\n    const executor = new TransformOperationExecutor(TransformationType.CLASS_TO_CLASS, {\n      ...defaultOptions,\n      ...options,\n    });\n    return executor.transform(fromObject, object, undefined, undefined, undefined, undefined);\n  }\n\n  /**\n   * Serializes given object to a JSON string.\n   */\n  serialize<T>(object: T, options?: ClassTransformOptions): string;\n  serialize<T>(object: T[], options?: ClassTransformOptions): string;\n  serialize<T>(object: T | T[], options?: ClassTransformOptions): string {\n    return JSON.stringify(this.instanceToPlain(object, options));\n  }\n\n  /**\n   * Deserializes given JSON string to a object of the given class.\n   */\n  deserialize<T>(cls: ClassConstructor<T>, json: string, options?: ClassTransformOptions): T {\n    const jsonObject: T = JSON.parse(json);\n    return this.plainToInstance(cls, jsonObject, options);\n  }\n\n  /**\n   * Deserializes given JSON string to an array of objects of the given class.\n   */\n  deserializeArray<T>(cls: ClassConstructor<T>, json: string, options?: ClassTransformOptions): T[] {\n    const jsonObject: any[] = JSON.parse(json);\n    return this.plainToInstance(cls, jsonObject, options);\n  }\n}\n","import { MetadataStorage } from './MetadataStorage';\n\n/**\n * Default metadata storage is used as singleton and can be used to storage all metadatas.\n */\nexport const defaultMetadataStorage = new MetadataStorage();\n","import { TypeMetadata, ExposeMetadata, ExcludeMetadata, TransformMetadata } from './interfaces';\nimport { TransformationType } from './enums';\n\n/**\n * Storage all library metadata.\n */\nexport class MetadataStorage {\n  // -------------------------------------------------------------------------\n  // Properties\n  // -------------------------------------------------------------------------\n\n  private _typeMetadatas = new Map<Function, Map<string, TypeMetadata>>();\n  private _transformMetadatas = new Map<Function, Map<string, TransformMetadata[]>>();\n  private _exposeMetadatas = new Map<Function, Map<string, ExposeMetadata>>();\n  private _excludeMetadatas = new Map<Function, Map<string, ExcludeMetadata>>();\n  private _ancestorsMap = new Map<Function, Function[]>();\n\n  // -------------------------------------------------------------------------\n  // Adder Methods\n  // -------------------------------------------------------------------------\n\n  addTypeMetadata(metadata: TypeMetadata): void {\n    if (!this._typeMetadatas.has(metadata.target)) {\n      this._typeMetadatas.set(metadata.target, new Map<string, TypeMetadata>());\n    }\n    this._typeMetadatas.get(metadata.target).set(metadata.propertyName, metadata);\n  }\n\n  addTransformMetadata(metadata: TransformMetadata): void {\n    if (!this._transformMetadatas.has(metadata.target)) {\n      this._transformMetadatas.set(metadata.target, new Map<string, TransformMetadata[]>());\n    }\n    if (!this._transformMetadatas.get(metadata.target).has(metadata.propertyName)) {\n      this._transformMetadatas.get(metadata.target).set(metadata.propertyName, []);\n    }\n    this._transformMetadatas.get(metadata.target).get(metadata.propertyName).push(metadata);\n  }\n\n  addExposeMetadata(metadata: ExposeMetadata): void {\n    if (!this._exposeMetadatas.has(metadata.target)) {\n      this._exposeMetadatas.set(metadata.target, new Map<string, ExposeMetadata>());\n    }\n    this._exposeMetadatas.get(metadata.target).set(metadata.propertyName, metadata);\n  }\n\n  addExcludeMetadata(metadata: ExcludeMetadata): void {\n    if (!this._excludeMetadatas.has(metadata.target)) {\n      this._excludeMetadatas.set(metadata.target, new Map<string, ExcludeMetadata>());\n    }\n    this._excludeMetadatas.get(metadata.target).set(metadata.propertyName, metadata);\n  }\n\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  findTransformMetadatas(\n    target: Function,\n    propertyName: string,\n    transformationType: TransformationType\n  ): TransformMetadata[] {\n    return this.findMetadatas(this._transformMetadatas, target, propertyName).filter(metadata => {\n      if (!metadata.options) return true;\n      if (metadata.options.toClassOnly === true && metadata.options.toPlainOnly === true) return true;\n\n      if (metadata.options.toClassOnly === true) {\n        return (\n          transformationType === TransformationType.CLASS_TO_CLASS ||\n          transformationType === TransformationType.PLAIN_TO_CLASS\n        );\n      }\n      if (metadata.options.toPlainOnly === true) {\n        return transformationType === TransformationType.CLASS_TO_PLAIN;\n      }\n\n      return true;\n    });\n  }\n\n  findExcludeMetadata(target: Function, propertyName: string): ExcludeMetadata {\n    return this.findMetadata(this._excludeMetadatas, target, propertyName);\n  }\n\n  findExposeMetadata(target: Function, propertyName: string): ExposeMetadata {\n    return this.findMetadata(this._exposeMetadatas, target, propertyName);\n  }\n\n  findExposeMetadataByCustomName(target: Function, name: string): ExposeMetadata {\n    return this.getExposedMetadatas(target).find(metadata => {\n      return metadata.options && metadata.options.name === name;\n    });\n  }\n\n  findTypeMetadata(target: Function, propertyName: string): TypeMetadata {\n    return this.findMetadata(this._typeMetadatas, target, propertyName);\n  }\n\n  getStrategy(target: Function): 'excludeAll' | 'exposeAll' | 'none' {\n    const excludeMap = this._excludeMetadatas.get(target);\n    const exclude = excludeMap && excludeMap.get(undefined);\n    const exposeMap = this._exposeMetadatas.get(target);\n    const expose = exposeMap && exposeMap.get(undefined);\n    if ((exclude && expose) || (!exclude && !expose)) return 'none';\n    return exclude ? 'excludeAll' : 'exposeAll';\n  }\n\n  getExposedMetadatas(target: Function): ExposeMetadata[] {\n    return this.getMetadata(this._exposeMetadatas, target);\n  }\n\n  getExcludedMetadatas(target: Function): ExcludeMetadata[] {\n    return this.getMetadata(this._excludeMetadatas, target);\n  }\n\n  getExposedProperties(target: Function, transformationType: TransformationType): string[] {\n    return this.getExposedMetadatas(target)\n      .filter(metadata => {\n        if (!metadata.options) return true;\n        if (metadata.options.toClassOnly === true && metadata.options.toPlainOnly === true) return true;\n\n        if (metadata.options.toClassOnly === true) {\n          return (\n            transformationType === TransformationType.CLASS_TO_CLASS ||\n            transformationType === TransformationType.PLAIN_TO_CLASS\n          );\n        }\n        if (metadata.options.toPlainOnly === true) {\n          return transformationType === TransformationType.CLASS_TO_PLAIN;\n        }\n\n        return true;\n      })\n      .map(metadata => metadata.propertyName);\n  }\n\n  getExcludedProperties(target: Function, transformationType: TransformationType): string[] {\n    return this.getExcludedMetadatas(target)\n      .filter(metadata => {\n        if (!metadata.options) return true;\n        if (metadata.options.toClassOnly === true && metadata.options.toPlainOnly === true) return true;\n\n        if (metadata.options.toClassOnly === true) {\n          return (\n            transformationType === TransformationType.CLASS_TO_CLASS ||\n            transformationType === TransformationType.PLAIN_TO_CLASS\n          );\n        }\n        if (metadata.options.toPlainOnly === true) {\n          return transformationType === TransformationType.CLASS_TO_PLAIN;\n        }\n\n        return true;\n      })\n      .map(metadata => metadata.propertyName);\n  }\n\n  clear(): void {\n    this._typeMetadatas.clear();\n    this._exposeMetadatas.clear();\n    this._excludeMetadatas.clear();\n    this._ancestorsMap.clear();\n  }\n\n  // -------------------------------------------------------------------------\n  // Private Methods\n  // -------------------------------------------------------------------------\n\n  private getMetadata<T extends { target: Function; propertyName: string }>(\n    metadatas: Map<Function, Map<string, T>>,\n    target: Function\n  ): T[] {\n    const metadataFromTargetMap = metadatas.get(target);\n    let metadataFromTarget: T[];\n    if (metadataFromTargetMap) {\n      metadataFromTarget = Array.from(metadataFromTargetMap.values()).filter(meta => meta.propertyName !== undefined);\n    }\n    const metadataFromAncestors: T[] = [];\n    for (const ancestor of this.getAncestors(target)) {\n      const ancestorMetadataMap = metadatas.get(ancestor);\n      if (ancestorMetadataMap) {\n        const metadataFromAncestor = Array.from(ancestorMetadataMap.values()).filter(\n          meta => meta.propertyName !== undefined\n        );\n        metadataFromAncestors.push(...metadataFromAncestor);\n      }\n    }\n    return metadataFromAncestors.concat(metadataFromTarget || []);\n  }\n\n  private findMetadata<T extends { target: Function; propertyName: string }>(\n    metadatas: Map<Function, Map<string, T>>,\n    target: Function,\n    propertyName: string\n  ): T {\n    const metadataFromTargetMap = metadatas.get(target);\n    if (metadataFromTargetMap) {\n      const metadataFromTarget = metadataFromTargetMap.get(propertyName);\n      if (metadataFromTarget) {\n        return metadataFromTarget;\n      }\n    }\n    for (const ancestor of this.getAncestors(target)) {\n      const ancestorMetadataMap = metadatas.get(ancestor);\n      if (ancestorMetadataMap) {\n        const ancestorResult = ancestorMetadataMap.get(propertyName);\n        if (ancestorResult) {\n          return ancestorResult;\n        }\n      }\n    }\n    return undefined;\n  }\n\n  private findMetadatas<T extends { target: Function; propertyName: string }>(\n    metadatas: Map<Function, Map<string, T[]>>,\n    target: Function,\n    propertyName: string\n  ): T[] {\n    const metadataFromTargetMap = metadatas.get(target);\n    let metadataFromTarget: T[];\n    if (metadataFromTargetMap) {\n      metadataFromTarget = metadataFromTargetMap.get(propertyName);\n    }\n    const metadataFromAncestorsTarget: T[] = [];\n    for (const ancestor of this.getAncestors(target)) {\n      const ancestorMetadataMap = metadatas.get(ancestor);\n      if (ancestorMetadataMap) {\n        if (ancestorMetadataMap.has(propertyName)) {\n          metadataFromAncestorsTarget.push(...ancestorMetadataMap.get(propertyName));\n        }\n      }\n    }\n    return metadataFromAncestorsTarget\n      .slice()\n      .reverse()\n      .concat((metadataFromTarget || []).slice().reverse());\n  }\n\n  private getAncestors(target: Function): Function[] {\n    if (!target) return [];\n    if (!this._ancestorsMap.has(target)) {\n      const ancestors: Function[] = [];\n      for (\n        let baseClass = Object.getPrototypeOf(target.prototype.constructor);\n        typeof baseClass.prototype !== 'undefined';\n        baseClass = Object.getPrototypeOf(baseClass.prototype.constructor)\n      ) {\n        ancestors.push(baseClass);\n      }\n      this._ancestorsMap.set(target, ancestors);\n    }\n    return this._ancestorsMap.get(target);\n  }\n}\n","/**\n * Container options.\n */\nexport interface UseContainerOptions {\n  /**\n   * If set to true, then default container will be used in the case if given container haven't returned anything.\n   */\n  fallback?: boolean;\n\n  /**\n   * If set to true, then default container will be used in the case if given container thrown an exception.\n   */\n  fallbackOnErrors?: boolean;\n}\n\n/**\n * Container to be used by this library for inversion control. If container was not implicitly set then by default\n * container simply creates a new instance of the given class.\n */\nconst defaultContainer: { get<T>(someClass: { new (...args: any[]): T } | Function): T } = new (class {\n  private instances: { type: Function; object: any }[] = [];\n  get<T>(someClass: { new (...args: any[]): T }): T {\n    let instance = this.instances.find(instance => instance.type === someClass);\n    if (!instance) {\n      instance = { type: someClass, object: new someClass() };\n      this.instances.push(instance);\n    }\n\n    return instance.object;\n  }\n})();\n\nlet userContainer: { get<T>(someClass: { new (...args: any[]): T } | Function): T };\nlet userContainerOptions: UseContainerOptions;\n\n/**\n * Sets container to be used by this library.\n */\nexport function useContainer(iocContainer: { get(someClass: any): any }, options?: UseContainerOptions): void {\n  userContainer = iocContainer;\n  userContainerOptions = options;\n}\n\n/**\n * Gets the IOC container used by this library.\n */\nexport function getFromContainer<T>(someClass: { new (...args: any[]): T } | Function): T {\n  if (userContainer) {\n    try {\n      const instance = userContainer.get(someClass);\n      if (instance) return instance;\n\n      if (!userContainerOptions || !userContainerOptions.fallback) return instance;\n    } catch (error) {\n      if (!userContainerOptions || !userContainerOptions.fallbackOnErrors) throw error;\n    }\n  }\n  return defaultContainer.get<T>(someClass);\n}\n","import { ValidationOptions } from '../ValidationOptions';\nimport { buildMessage, ValidateBy } from './ValidateBy';\nimport { ValidationTypes } from '../../validation/ValidationTypes';\n\n// isDefined is (yet) a special case\nexport const IS_DEFINED = ValidationTypes.IS_DEFINED;\n\n/**\n * Checks if value is defined (!== undefined, !== null).\n */\nexport function isDefined(value: any): boolean {\n  return value !== undefined && value !== null;\n}\n\n/**\n * Checks if value is defined (!== undefined, !== null).\n */\nexport function IsDefined(validationOptions?: ValidationOptions): PropertyDecorator {\n  return ValidateBy(\n    {\n      name: IS_DEFINED,\n      validator: {\n        validate: (value): boolean => isDefined(value),\n        defaultMessage: buildMessage(\n          eachPrefix => eachPrefix + '$property should not be null or undefined',\n          validationOptions\n        ),\n      },\n    },\n    validationOptions\n  );\n}\n","import { ValidatorConstraintInterface } from '../validation/ValidatorConstraintInterface';\nimport { getFromContainer } from '../container';\n\n/**\n * This metadata interface contains information for custom validators.\n */\nexport class ConstraintMetadata {\n  // -------------------------------------------------------------------------\n  // Properties\n  // -------------------------------------------------------------------------\n\n  /**\n   * Target class which performs validation.\n   */\n  target: Function;\n\n  /**\n   * Custom validation's name, that will be used as validation error type.\n   */\n  name: string;\n\n  /**\n   * Indicates if this validation is asynchronous or not.\n   */\n  async: boolean;\n\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n\n  constructor(target: Function, name?: string, async: boolean = false) {\n    this.target = target;\n    this.name = name;\n    this.async = async;\n  }\n\n  // -------------------------------------------------------------------------\n  // Accessors\n  // -------------------------------------------------------------------------\n\n  /**\n   * Instance of the target custom validation class which performs validation.\n   */\n  get instance(): ValidatorConstraintInterface {\n    return getFromContainer<ValidatorConstraintInterface>(this.target);\n  }\n}\n","import { ValidationOptions } from '../ValidationOptions';\nimport { registerDecorator } from '../../register-decorator';\nimport { ValidationArguments } from '../../validation/ValidationArguments';\nimport { ValidatorConstraintInterface } from '../../validation/ValidatorConstraintInterface';\n\nexport interface ValidateByOptions {\n  name: string;\n  constraints?: any[];\n  validator: ValidatorConstraintInterface | Function;\n  async?: boolean;\n}\n\nexport function buildMessage(\n  impl: (eachPrefix: string, args?: ValidationArguments) => string,\n  validationOptions?: ValidationOptions\n): (validationArguments?: ValidationArguments) => string {\n  return (validationArguments?: ValidationArguments): string => {\n    const eachPrefix = validationOptions && validationOptions.each ? 'each value in ' : '';\n    return impl(eachPrefix, validationArguments);\n  };\n}\n\nexport function ValidateBy(options: ValidateByOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n  return function (object: object, propertyName: string): void {\n    registerDecorator({\n      name: options.name,\n      target: object.constructor,\n      propertyName: propertyName,\n      options: validationOptions,\n      constraints: options.constraints,\n      validator: options.validator,\n    });\n  };\n}\n","import { ConstraintMetadata } from './metadata/ConstraintMetadata';\nimport { ValidatorConstraintInterface } from './validation/ValidatorConstraintInterface';\nimport { ValidationMetadata } from './metadata/ValidationMetadata';\nimport { ValidationMetadataArgs } from './metadata/ValidationMetadataArgs';\nimport { ValidationTypes } from './validation/ValidationTypes';\nimport { ValidationArguments } from './validation/ValidationArguments';\nimport { getFromContainer } from './container';\nimport { MetadataStorage, getMetadataStorage } from './metadata/MetadataStorage';\nimport { ValidationOptions } from './decorator/ValidationOptions';\n\nexport interface ValidationDecoratorOptions {\n  /**\n   * Target object to be validated.\n   */\n  target: Function;\n\n  /**\n   * Target object's property name to be validated.\n   */\n  propertyName: string;\n\n  /**\n   * Name of the validation that is being registered.\n   */\n  name?: string;\n\n  /**\n   * Indicates if this decorator will perform async validation.\n   */\n  async?: boolean;\n\n  /**\n   * Validator options.\n   */\n  options?: ValidationOptions;\n\n  /**\n   * Array of validation constraints.\n   */\n  constraints?: any[];\n\n  /**\n   * Validator that performs validation.\n   */\n  validator: ValidatorConstraintInterface | Function;\n}\n\n/**\n * Registers a custom validation decorator.\n */\nexport function registerDecorator(options: ValidationDecoratorOptions): void {\n  let constraintCls: Function;\n  if (options.validator instanceof Function) {\n    constraintCls = options.validator;\n    const constraintClasses = getFromContainer(MetadataStorage).getTargetValidatorConstraints(options.validator);\n    if (constraintClasses.length > 1) {\n      throw `More than one implementation of ValidatorConstraintInterface found for validator on: ${options.target.name}:${options.propertyName}`;\n    }\n  } else {\n    const validator = options.validator;\n    constraintCls = class CustomConstraint implements ValidatorConstraintInterface {\n      validate(value: any, validationArguments?: ValidationArguments): Promise<boolean> | boolean {\n        return validator.validate(value, validationArguments);\n      }\n\n      defaultMessage(validationArguments?: ValidationArguments): string {\n        if (validator.defaultMessage) {\n          return validator.defaultMessage(validationArguments);\n        }\n\n        return '';\n      }\n    };\n    getMetadataStorage().addConstraintMetadata(new ConstraintMetadata(constraintCls, options.name, options.async));\n  }\n\n  const validationMetadataArgs: ValidationMetadataArgs = {\n    type: options.name && ValidationTypes.isValid(options.name) ? options.name : ValidationTypes.CUSTOM_VALIDATION,\n    name: options.name,\n    target: options.target,\n    propertyName: options.propertyName,\n    validationOptions: options.options,\n    constraintCls: constraintCls,\n    constraints: options.constraints,\n  };\n  getMetadataStorage().addValidationMetadata(new ValidationMetadata(validationMetadataArgs));\n}\n","import { ValidationOptions } from '../ValidationOptions';\nimport { ValidationMetadataArgs } from '../../metadata/ValidationMetadataArgs';\nimport { ValidationTypes } from '../../validation/ValidationTypes';\nimport { ValidationMetadata } from '../../metadata/ValidationMetadata';\nimport { getMetadataStorage } from '../../metadata/MetadataStorage';\n\n/**\n * Objects / object arrays marked with this decorator will also be validated.\n */\nexport function ValidateNested(validationOptions?: ValidationOptions): PropertyDecorator {\n  const opts: ValidationOptions = { ...validationOptions };\n  const eachPrefix = opts.each ? 'each value in ' : '';\n  opts.message = opts.message || eachPrefix + 'nested property $property must be either object or array';\n\n  return function (object: object, propertyName: string): void {\n    const args: ValidationMetadataArgs = {\n      type: ValidationTypes.NESTED_VALIDATION,\n      target: object.constructor,\n      propertyName: propertyName,\n      validationOptions: opts,\n    };\n    getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n  };\n}\n","import { ValidationOptions } from '../ValidationOptions';\nimport { buildMessage, ValidateBy } from '../common/ValidateBy';\nimport isUrlValidator from 'validator/lib/isURL';\nimport ValidatorJS from 'validator';\n\nexport const IS_URL = 'isUrl';\n\n/**\n * Checks if the string is a url.\n * If given value is not a string, then it returns false.\n */\nexport function isURL(value: string, options?: ValidatorJS.IsURLOptions): boolean {\n  return typeof value === 'string' && isUrlValidator(value, options);\n}\n\n/**\n * Checks if the string is a url.\n * If given value is not a string, then it returns false.\n */\nexport function IsUrl(options?: ValidatorJS.IsURLOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n  return ValidateBy(\n    {\n      name: IS_URL,\n      constraints: [options],\n      validator: {\n        validate: (value, args): boolean => isURL(value, args?.constraints[0]),\n        defaultMessage: buildMessage(eachPrefix => eachPrefix + '$property must be a URL address', validationOptions),\n      },\n    },\n    validationOptions\n  );\n}\n","import { ValidationOptions } from '../ValidationOptions';\nimport { buildMessage, ValidateBy } from '../common/ValidateBy';\n\nexport const IS_ARRAY = 'isArray';\n\n/**\n * Checks if a given value is an array\n */\nexport function isArray<T = any>(value: unknown): value is Array<T> {\n  return Array.isArray(value);\n}\n\n/**\n * Checks if a given value is an array\n */\nexport function IsArray(validationOptions?: ValidationOptions): PropertyDecorator {\n  return ValidateBy(\n    {\n      name: IS_ARRAY,\n      validator: {\n        validate: (value, args): boolean => isArray(value),\n        defaultMessage: buildMessage(eachPrefix => eachPrefix + '$property must be an array', validationOptions),\n      },\n    },\n    validationOptions\n  );\n}\n","import { ValidationOptions } from '../ValidationOptions';\nimport { buildMessage, ValidateBy } from '../common/ValidateBy';\n\nexport const IS_STRING = 'isString';\n\n/**\n * Checks if a given value is a real string.\n */\nexport function isString(value: unknown): value is string {\n  return value instanceof String || typeof value === 'string';\n}\n\n/**\n * Checks if a given value is a real string.\n */\nexport function IsString(validationOptions?: ValidationOptions): PropertyDecorator {\n  return ValidateBy(\n    {\n      name: IS_STRING,\n      validator: {\n        validate: (value, args): boolean => isString(value),\n        defaultMessage: buildMessage(eachPrefix => eachPrefix + '$property must be a string', validationOptions),\n      },\n    },\n    validationOptions\n  );\n}\n","/**\n * Validation error description.\n */\nexport class ValidationError {\n  /**\n   * Object that was validated.\n   *\n   * OPTIONAL - configurable via the ValidatorOptions.validationError.target option\n   */\n  target?: object;\n\n  /**\n   * Object's property that haven't pass validation.\n   */\n  property: string;\n\n  /**\n   * Value that haven't pass a validation.\n   *\n   * OPTIONAL - configurable via the ValidatorOptions.validationError.value option\n   */\n  value?: any;\n\n  /**\n   * Constraints that failed validation with error messages.\n   */\n  constraints?: {\n    [type: string]: string;\n  };\n\n  /**\n   * Contains all nested validation errors of the property.\n   */\n  children?: ValidationError[];\n\n  /*\n   * A transient set of data passed through to the validation result for response mapping\n   */\n  contexts?: {\n    [type: string]: any;\n  };\n\n  /**\n   *\n   * @param shouldDecorate decorate the message with ANSI formatter escape codes for better readability\n   * @param hasParent true when the error is a child of an another one\n   * @param parentPath path as string to the parent of this property\n   * @param showConstraintMessages show constraint messages instead of constraint names\n   */\n  toString(\n    shouldDecorate: boolean = false,\n    hasParent: boolean = false,\n    parentPath: string = ``,\n    showConstraintMessages: boolean = false\n  ): string {\n    const boldStart = shouldDecorate ? `\\x1b[1m` : ``;\n    const boldEnd = shouldDecorate ? `\\x1b[22m` : ``;\n    const constraintsToString = () =>\n      (showConstraintMessages ? Object.values : Object.keys)(this.constraints ?? {}).join(`, `);\n    const propConstraintFailed = (propertyName: string): string =>\n      ` - property ${boldStart}${parentPath}${propertyName}${boldEnd} has failed the following constraints: ${boldStart}${constraintsToString()}${boldEnd} \\n`;\n\n    if (!hasParent) {\n      return (\n        `An instance of ${boldStart}${\n          this.target ? this.target.constructor.name : 'an object'\n        }${boldEnd} has failed the validation:\\n` +\n        (this.constraints ? propConstraintFailed(this.property) : ``) +\n        (this.children\n          ? this.children\n              .map(childError => childError.toString(shouldDecorate, true, this.property, showConstraintMessages))\n              .join(``)\n          : ``)\n      );\n    } else {\n      // we format numbers as array indexes for better readability.\n      const formattedProperty = Number.isInteger(+this.property)\n        ? `[${this.property}]`\n        : `${parentPath ? `.` : ``}${this.property}`;\n\n      if (this.constraints) {\n        return propConstraintFailed(formattedProperty);\n      } else {\n        return this.children\n          ? this.children\n              .map(childError =>\n                childError.toString(shouldDecorate, true, `${parentPath}${formattedProperty}`, showConstraintMessages)\n              )\n              .join(``)\n          : ``;\n      }\n    }\n  }\n}\n","import { ValidationArguments } from './ValidationArguments';\n\n/**\n * Convert the constraint to a string to be shown in an error\n */\nexport function constraintToString(constraint: unknown): string {\n  if (Array.isArray(constraint)) {\n    return constraint.join(', ');\n  }\n\n  if (typeof constraint === 'symbol') {\n    constraint = constraint.description;\n  }\n\n  return `${constraint}`;\n}\n\nexport class ValidationUtils {\n  static replaceMessageSpecialTokens(\n    message: string | ((args: ValidationArguments) => string),\n    validationArguments: ValidationArguments\n  ): string {\n    let messageString: string;\n    if (message instanceof Function) {\n      messageString = (message as (args: ValidationArguments) => string)(validationArguments);\n    } else if (typeof message === 'string') {\n      messageString = message;\n    }\n\n    if (messageString && Array.isArray(validationArguments.constraints)) {\n      validationArguments.constraints.forEach((constraint, index) => {\n        messageString = messageString.replace(\n          new RegExp(`\\\\$constraint${index + 1}`, 'g'),\n          constraintToString(constraint)\n        );\n      });\n    }\n\n    if (\n      messageString &&\n      validationArguments.value !== undefined &&\n      validationArguments.value !== null &&\n      typeof validationArguments.value === 'string'\n    )\n      messageString = messageString.replace(/\\$value/g, validationArguments.value);\n    if (messageString) messageString = messageString.replace(/\\$property/g, validationArguments.property);\n    if (messageString) messageString = messageString.replace(/\\$target/g, validationArguments.targetName);\n\n    return messageString;\n  }\n}\n","import { Validator } from './Validator';\nimport { ValidationError } from './ValidationError';\nimport { ValidationMetadata } from '../metadata/ValidationMetadata';\nimport { ValidatorOptions } from './ValidatorOptions';\nimport { ValidationTypes } from './ValidationTypes';\nimport { ConstraintMetadata } from '../metadata/ConstraintMetadata';\nimport { ValidationArguments } from './ValidationArguments';\nimport { ValidationUtils } from './ValidationUtils';\nimport { isPromise, convertToArray } from '../utils';\nimport { getMetadataStorage } from '../metadata/MetadataStorage';\n\n/**\n * Executes validation over given object.\n */\nexport class ValidationExecutor {\n  // -------------------------------------------------------------------------\n  // Properties\n  // -------------------------------------------------------------------------\n\n  awaitingPromises: Promise<any>[] = [];\n  ignoreAsyncValidations: boolean = false;\n\n  // -------------------------------------------------------------------------\n  // Private Properties\n  // -------------------------------------------------------------------------\n\n  private metadataStorage = getMetadataStorage();\n\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n\n  constructor(private validator: Validator, private validatorOptions?: ValidatorOptions) {}\n\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  execute(object: object, targetSchema: string, validationErrors: ValidationError[]): void {\n    /**\n     * If there is no metadata registered it means possibly the dependencies are not flatterned and\n     * more than one instance is used.\n     *\n     * TODO: This needs proper handling, forcing to use the same container or some other proper solution.\n     */\n    if (!this.metadataStorage.hasValidationMetaData && this.validatorOptions?.enableDebugMessages === true) {\n      console.warn(\n        `No validation metadata found. No validation will be  performed. There are multiple possible reasons:\\n` +\n          `  - There may be multiple class-validator versions installed. You will need to flatten your dependencies to fix the issue.\\n` +\n          `  - This validation runs before any file with validation decorator was parsed by NodeJS.`\n      );\n    }\n\n    const groups = this.validatorOptions ? this.validatorOptions.groups : undefined;\n    const strictGroups = (this.validatorOptions && this.validatorOptions.strictGroups) || false;\n    const always = (this.validatorOptions && this.validatorOptions.always) || false;\n    /** Forbid unknown values are turned on by default and any other value than false will enable it. */\n    const forbidUnknownValues =\n      this.validatorOptions?.forbidUnknownValues === undefined || this.validatorOptions.forbidUnknownValues !== false;\n\n    const targetMetadatas = this.metadataStorage.getTargetValidationMetadatas(\n      object.constructor,\n      targetSchema,\n      always,\n      strictGroups,\n      groups\n    );\n    const groupedMetadatas = this.metadataStorage.groupByPropertyName(targetMetadatas);\n\n    if (this.validatorOptions && forbidUnknownValues && !targetMetadatas.length) {\n      const validationError = new ValidationError();\n\n      if (\n        !this.validatorOptions ||\n        !this.validatorOptions.validationError ||\n        this.validatorOptions.validationError.target === undefined ||\n        this.validatorOptions.validationError.target === true\n      )\n        validationError.target = object;\n\n      validationError.value = undefined;\n      validationError.property = undefined;\n      validationError.children = [];\n      validationError.constraints = { unknownValue: 'an unknown value was passed to the validate function' };\n\n      validationErrors.push(validationError);\n\n      return;\n    }\n\n    if (this.validatorOptions && this.validatorOptions.whitelist)\n      this.whitelist(object, groupedMetadatas, validationErrors);\n\n    // General validation\n    Object.keys(groupedMetadatas).forEach(propertyName => {\n      const value = (object as any)[propertyName];\n      const definedMetadatas = groupedMetadatas[propertyName].filter(\n        metadata => metadata.type === ValidationTypes.IS_DEFINED\n      );\n      const metadatas = groupedMetadatas[propertyName].filter(\n        metadata => metadata.type !== ValidationTypes.IS_DEFINED && metadata.type !== ValidationTypes.WHITELIST\n      );\n\n      if (\n        value instanceof Promise &&\n        metadatas.find(metadata => metadata.type === ValidationTypes.PROMISE_VALIDATION)\n      ) {\n        this.awaitingPromises.push(\n          value.then(resolvedValue => {\n            this.performValidations(object, resolvedValue, propertyName, definedMetadatas, metadatas, validationErrors);\n          })\n        );\n      } else {\n        this.performValidations(object, value, propertyName, definedMetadatas, metadatas, validationErrors);\n      }\n    });\n  }\n\n  whitelist(\n    object: any,\n    groupedMetadatas: { [propertyName: string]: ValidationMetadata[] },\n    validationErrors: ValidationError[]\n  ): void {\n    const notAllowedProperties: string[] = [];\n\n    Object.keys(object).forEach(propertyName => {\n      // does this property have no metadata?\n      if (!groupedMetadatas[propertyName] || groupedMetadatas[propertyName].length === 0)\n        notAllowedProperties.push(propertyName);\n    });\n\n    if (notAllowedProperties.length > 0) {\n      if (this.validatorOptions && this.validatorOptions.forbidNonWhitelisted) {\n        // throw errors\n        notAllowedProperties.forEach(property => {\n          const validationError: ValidationError = this.generateValidationError(object, object[property], property);\n          validationError.constraints = { [ValidationTypes.WHITELIST]: `property ${property} should not exist` };\n          validationError.children = undefined;\n          validationErrors.push(validationError);\n        });\n      } else {\n        // strip non allowed properties\n        notAllowedProperties.forEach(property => delete object[property]);\n      }\n    }\n  }\n\n  stripEmptyErrors(errors: ValidationError[]): ValidationError[] {\n    return errors.filter(error => {\n      if (error.children) {\n        error.children = this.stripEmptyErrors(error.children);\n      }\n\n      if (Object.keys(error.constraints).length === 0) {\n        if (error.children.length === 0) {\n          return false;\n        } else {\n          delete error.constraints;\n        }\n      }\n\n      return true;\n    });\n  }\n\n  // -------------------------------------------------------------------------\n  // Private Methods\n  // -------------------------------------------------------------------------\n\n  private performValidations(\n    object: any,\n    value: any,\n    propertyName: string,\n    definedMetadatas: ValidationMetadata[],\n    metadatas: ValidationMetadata[],\n    validationErrors: ValidationError[]\n  ): void {\n    const customValidationMetadatas = metadatas.filter(metadata => metadata.type === ValidationTypes.CUSTOM_VALIDATION);\n    const nestedValidationMetadatas = metadatas.filter(metadata => metadata.type === ValidationTypes.NESTED_VALIDATION);\n    const conditionalValidationMetadatas = metadatas.filter(\n      metadata => metadata.type === ValidationTypes.CONDITIONAL_VALIDATION\n    );\n\n    const validationError = this.generateValidationError(object, value, propertyName);\n    validationErrors.push(validationError);\n\n    const canValidate = this.conditionalValidations(object, value, conditionalValidationMetadatas);\n    if (!canValidate) {\n      return;\n    }\n\n    // handle IS_DEFINED validation type the special way - it should work no matter skipUndefinedProperties/skipMissingProperties is set or not\n    this.customValidations(object, value, definedMetadatas, validationError);\n    this.mapContexts(object, value, definedMetadatas, validationError);\n\n    if (value === undefined && this.validatorOptions && this.validatorOptions.skipUndefinedProperties === true) {\n      return;\n    }\n\n    if (value === null && this.validatorOptions && this.validatorOptions.skipNullProperties === true) {\n      return;\n    }\n\n    if (\n      (value === null || value === undefined) &&\n      this.validatorOptions &&\n      this.validatorOptions.skipMissingProperties === true\n    ) {\n      return;\n    }\n\n    this.customValidations(object, value, customValidationMetadatas, validationError);\n    this.nestedValidations(value, nestedValidationMetadatas, validationError);\n\n    this.mapContexts(object, value, metadatas, validationError);\n    this.mapContexts(object, value, customValidationMetadatas, validationError);\n  }\n\n  private generateValidationError(object: object, value: any, propertyName: string): ValidationError {\n    const validationError = new ValidationError();\n\n    if (\n      !this.validatorOptions ||\n      !this.validatorOptions.validationError ||\n      this.validatorOptions.validationError.target === undefined ||\n      this.validatorOptions.validationError.target === true\n    )\n      validationError.target = object;\n\n    if (\n      !this.validatorOptions ||\n      !this.validatorOptions.validationError ||\n      this.validatorOptions.validationError.value === undefined ||\n      this.validatorOptions.validationError.value === true\n    )\n      validationError.value = value;\n\n    validationError.property = propertyName;\n    validationError.children = [];\n    validationError.constraints = {};\n\n    return validationError;\n  }\n\n  private conditionalValidations(object: object, value: any, metadatas: ValidationMetadata[]): ValidationMetadata[] {\n    return metadatas\n      .map(metadata => metadata.constraints[0](object, value))\n      .reduce((resultA, resultB) => resultA && resultB, true);\n  }\n\n  private customValidations(object: object, value: any, metadatas: ValidationMetadata[], error: ValidationError): void {\n    metadatas.forEach(metadata => {\n      this.metadataStorage.getTargetValidatorConstraints(metadata.constraintCls).forEach(customConstraintMetadata => {\n        if (customConstraintMetadata.async && this.ignoreAsyncValidations) return;\n        if (\n          this.validatorOptions &&\n          this.validatorOptions.stopAtFirstError &&\n          Object.keys(error.constraints || {}).length > 0\n        )\n          return;\n\n        const validationArguments: ValidationArguments = {\n          targetName: object.constructor ? (object.constructor as any).name : undefined,\n          property: metadata.propertyName,\n          object: object,\n          value: value,\n          constraints: metadata.constraints,\n        };\n\n        if (!metadata.each || !(Array.isArray(value) || value instanceof Set || value instanceof Map)) {\n          const validatedValue = customConstraintMetadata.instance.validate(value, validationArguments);\n          if (isPromise(validatedValue)) {\n            const promise = validatedValue.then(isValid => {\n              if (!isValid) {\n                const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                error.constraints[type] = message;\n                if (metadata.context) {\n                  if (!error.contexts) {\n                    error.contexts = {};\n                  }\n                  error.contexts[type] = Object.assign(error.contexts[type] || {}, metadata.context);\n                }\n              }\n            });\n            this.awaitingPromises.push(promise);\n          } else {\n            if (!validatedValue) {\n              const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n              error.constraints[type] = message;\n            }\n          }\n\n          return;\n        }\n\n        // convert set and map into array\n        const arrayValue = convertToArray(value);\n        // Validation needs to be applied to each array item\n        const validatedSubValues = arrayValue.map((subValue: any) =>\n          customConstraintMetadata.instance.validate(subValue, validationArguments)\n        );\n        const validationIsAsync = validatedSubValues.some((validatedSubValue: boolean | Promise<boolean>) =>\n          isPromise(validatedSubValue)\n        );\n\n        if (validationIsAsync) {\n          // Wrap plain values (if any) in promises, so that all are async\n          const asyncValidatedSubValues = validatedSubValues.map((validatedSubValue: boolean | Promise<boolean>) =>\n            isPromise(validatedSubValue) ? validatedSubValue : Promise.resolve(validatedSubValue)\n          );\n          const asyncValidationIsFinishedPromise = Promise.all(asyncValidatedSubValues).then(\n            (flatValidatedValues: boolean[]) => {\n              const validationResult = flatValidatedValues.every((isValid: boolean) => isValid);\n              if (!validationResult) {\n                const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                error.constraints[type] = message;\n                if (metadata.context) {\n                  if (!error.contexts) {\n                    error.contexts = {};\n                  }\n                  error.contexts[type] = Object.assign(error.contexts[type] || {}, metadata.context);\n                }\n              }\n            }\n          );\n\n          this.awaitingPromises.push(asyncValidationIsFinishedPromise);\n\n          return;\n        }\n\n        const validationResult = validatedSubValues.every((isValid: boolean) => isValid);\n        if (!validationResult) {\n          const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n          error.constraints[type] = message;\n        }\n      });\n    });\n  }\n\n  private nestedValidations(value: any, metadatas: ValidationMetadata[], error: ValidationError): void {\n    if (value === void 0) {\n      return;\n    }\n\n    metadatas.forEach(metadata => {\n      if (metadata.type !== ValidationTypes.NESTED_VALIDATION && metadata.type !== ValidationTypes.PROMISE_VALIDATION) {\n        return;\n      } else if (\n        this.validatorOptions &&\n        this.validatorOptions.stopAtFirstError &&\n        Object.keys(error.constraints || {}).length > 0\n      ) {\n        return;\n      }\n\n      if (Array.isArray(value) || value instanceof Set || value instanceof Map) {\n        // Treats Set as an array - as index of Set value is value itself and it is common case to have Object as value\n        const arrayLikeValue = value instanceof Set ? Array.from(value) : value;\n        arrayLikeValue.forEach((subValue: any, index: any) => {\n          this.performValidations(value, subValue, index.toString(), [], metadatas, error.children);\n        });\n      } else if (value instanceof Object) {\n        const targetSchema = typeof metadata.target === 'string' ? metadata.target : metadata.target.name;\n        this.execute(value, targetSchema, error.children);\n      } else {\n        const [type, message] = this.createValidationError(metadata.target as object, value, metadata);\n        error.constraints[type] = message;\n      }\n    });\n  }\n\n  private mapContexts(object: object, value: any, metadatas: ValidationMetadata[], error: ValidationError): void {\n    return metadatas.forEach(metadata => {\n      if (metadata.context) {\n        let customConstraint;\n        if (metadata.type === ValidationTypes.CUSTOM_VALIDATION) {\n          const customConstraints = this.metadataStorage.getTargetValidatorConstraints(metadata.constraintCls);\n          customConstraint = customConstraints[0];\n        }\n\n        const type = this.getConstraintType(metadata, customConstraint);\n\n        if (error.constraints[type]) {\n          if (!error.contexts) {\n            error.contexts = {};\n          }\n\n          error.contexts[type] = Object.assign(error.contexts[type] || {}, metadata.context);\n        }\n      }\n    });\n  }\n\n  private createValidationError(\n    object: object,\n    value: any,\n    metadata: ValidationMetadata,\n    customValidatorMetadata?: ConstraintMetadata\n  ): [string, string] {\n    const targetName = object.constructor ? (object.constructor as any).name : undefined;\n    const type = this.getConstraintType(metadata, customValidatorMetadata);\n    const validationArguments: ValidationArguments = {\n      targetName: targetName,\n      property: metadata.propertyName,\n      object: object,\n      value: value,\n      constraints: metadata.constraints,\n    };\n\n    let message = metadata.message || '';\n    if (\n      !metadata.message &&\n      (!this.validatorOptions || (this.validatorOptions && !this.validatorOptions.dismissDefaultMessages))\n    ) {\n      if (customValidatorMetadata && customValidatorMetadata.instance.defaultMessage instanceof Function) {\n        message = customValidatorMetadata.instance.defaultMessage(validationArguments);\n      }\n    }\n\n    const messageString = ValidationUtils.replaceMessageSpecialTokens(message, validationArguments);\n    return [type, messageString];\n  }\n\n  private getConstraintType(metadata: ValidationMetadata, customValidatorMetadata?: ConstraintMetadata): string {\n    const type = customValidatorMetadata && customValidatorMetadata.name ? customValidatorMetadata.name : metadata.type;\n    return type;\n  }\n}\n","/**\n * Convert Map, Set to Array\n */\nexport function convertToArray<T>(val: Array<T> | Set<T> | Map<any, T>): Array<T> {\n  if (val instanceof Map) {\n    return Array.from(val.values());\n  }\n  return Array.isArray(val) ? val : Array.from(val);\n}\n","import { ValidationError } from './ValidationError';\nimport { ValidatorOptions } from './ValidatorOptions';\nimport { ValidationExecutor } from './ValidationExecutor';\nimport { ValidationOptions } from '../decorator/ValidationOptions';\n\n/**\n * Validator performs validation of the given object based on its metadata.\n */\nexport class Validator {\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Performs validation of the given object based on decorators used in given object class.\n   */\n  validate(object: object, options?: ValidatorOptions): Promise<ValidationError[]>;\n\n  /**\n   * Performs validation of the given object based on validation schema.\n   */\n  validate(schemaName: string, object: object, options?: ValidatorOptions): Promise<ValidationError[]>;\n\n  /**\n   * Performs validation of the given object based on decorators or validation schema.\n   */\n  validate(\n    objectOrSchemaName: object | string,\n    objectOrValidationOptions: object | ValidationOptions,\n    maybeValidatorOptions?: ValidatorOptions\n  ): Promise<ValidationError[]> {\n    return this.coreValidate(objectOrSchemaName, objectOrValidationOptions, maybeValidatorOptions);\n  }\n\n  /**\n   * Performs validation of the given object based on decorators used in given object class and reject on error.\n   */\n  validateOrReject(object: object, options?: ValidatorOptions): Promise<void>;\n\n  /**\n   * Performs validation of the given object based on validation schema and reject on error.\n   */\n  validateOrReject(schemaName: string, object: object, options?: ValidatorOptions): Promise<void>;\n\n  /**\n   * Performs validation of the given object based on decorators or validation schema and reject on error.\n   */\n  async validateOrReject(\n    objectOrSchemaName: object | string,\n    objectOrValidationOptions: object | ValidationOptions,\n    maybeValidatorOptions?: ValidatorOptions\n  ): Promise<void> {\n    const errors = await this.coreValidate(objectOrSchemaName, objectOrValidationOptions, maybeValidatorOptions);\n    if (errors.length) return Promise.reject(errors);\n  }\n\n  /**\n   * Performs validation of the given object based on decorators used in given object class.\n   * NOTE: This method completely ignores all async validations.\n   */\n  validateSync(object: object, options?: ValidatorOptions): ValidationError[];\n\n  /**\n   * Performs validation of the given object based on validation schema.\n   */\n  validateSync(schemaName: string, object: object, options?: ValidatorOptions): ValidationError[];\n\n  /**\n   * Performs validation of the given object based on decorators or validation schema.\n   */\n  validateSync(\n    objectOrSchemaName: object | string,\n    objectOrValidationOptions: object | ValidationOptions,\n    maybeValidatorOptions?: ValidatorOptions\n  ): ValidationError[] {\n    const object = typeof objectOrSchemaName === 'string' ? (objectOrValidationOptions as object) : objectOrSchemaName;\n    const options =\n      typeof objectOrSchemaName === 'string' ? maybeValidatorOptions : (objectOrValidationOptions as ValidationOptions);\n    const schema = typeof objectOrSchemaName === 'string' ? objectOrSchemaName : undefined;\n\n    const executor = new ValidationExecutor(this, options);\n    executor.ignoreAsyncValidations = true;\n    const validationErrors: ValidationError[] = [];\n    executor.execute(object, schema, validationErrors);\n    return executor.stripEmptyErrors(validationErrors);\n  }\n\n  // -------------------------------------------------------------------------\n  // Private Properties\n  // -------------------------------------------------------------------------\n  /**\n   * Performs validation of the given object based on decorators or validation schema.\n   * Common method for `validateOrReject` and `validate` methods.\n   */\n  private coreValidate(\n    objectOrSchemaName: object | string,\n    objectOrValidationOptions: object | ValidationOptions,\n    maybeValidatorOptions?: ValidatorOptions\n  ): Promise<ValidationError[]> {\n    const object = typeof objectOrSchemaName === 'string' ? (objectOrValidationOptions as object) : objectOrSchemaName;\n    const options =\n      typeof objectOrSchemaName === 'string' ? maybeValidatorOptions : (objectOrValidationOptions as ValidationOptions);\n    const schema = typeof objectOrSchemaName === 'string' ? objectOrSchemaName : undefined;\n\n    const executor = new ValidationExecutor(this, options);\n    const validationErrors: ValidationError[] = [];\n    executor.execute(object, schema, validationErrors);\n\n    return Promise.all(executor.awaitingPromises).then(() => {\n      return executor.stripEmptyErrors(validationErrors);\n    });\n  }\n}\n","import { ValidationSchema } from './ValidationSchema';\nimport { ValidationMetadata } from '../metadata/ValidationMetadata';\nimport { ValidationMetadataArgs } from '../metadata/ValidationMetadataArgs';\nimport { ValidationOptions } from '../decorator/ValidationOptions';\n\n/**\n * Used to transform validation schemas to validation metadatas.\n */\nexport class ValidationSchemaToMetadataTransformer {\n  transform(schema: ValidationSchema): ValidationMetadata[] {\n    const metadatas: ValidationMetadata[] = [];\n    Object.keys(schema.properties).forEach(property => {\n      schema.properties[property].forEach(validation => {\n        const validationOptions: ValidationOptions = {\n          message: validation.message,\n          groups: validation.groups,\n          always: validation.always,\n          each: validation.each,\n        };\n        const args: ValidationMetadataArgs = {\n          type: validation.type,\n          name: validation.name,\n          target: schema.name,\n          propertyName: property,\n          constraints: validation.constraints,\n          validationTypeOptions: validation.options,\n          validationOptions: validationOptions,\n        };\n        metadatas.push(new ValidationMetadata(args));\n      });\n    });\n    return metadatas;\n  }\n}\n","import { ValidationMetadata } from './ValidationMetadata';\nimport { ConstraintMetadata } from './ConstraintMetadata';\nimport { ValidationSchema } from '../validation-schema/ValidationSchema';\nimport { ValidationSchemaToMetadataTransformer } from '../validation-schema/ValidationSchemaToMetadataTransformer';\nimport { getGlobal } from '../utils';\n\n/**\n * Storage all metadatas.\n */\nexport class MetadataStorage {\n  // -------------------------------------------------------------------------\n  // Private properties\n  // -------------------------------------------------------------------------\n\n  private validationMetadatas: Map<any, ValidationMetadata[]> = new Map();\n  private constraintMetadatas: Map<any, ConstraintMetadata[]> = new Map();\n\n  get hasValidationMetaData(): boolean {\n    return !!this.validationMetadatas.size;\n  }\n\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Adds a new validation metadata.\n   */\n  addValidationSchema(schema: ValidationSchema): void {\n    const validationMetadatas = new ValidationSchemaToMetadataTransformer().transform(schema);\n    validationMetadatas.forEach(validationMetadata => this.addValidationMetadata(validationMetadata));\n  }\n\n  /**\n   * Adds a new validation metadata.\n   */\n  addValidationMetadata(metadata: ValidationMetadata): void {\n    const existingMetadata = this.validationMetadatas.get(metadata.target);\n\n    if (existingMetadata) {\n      existingMetadata.push(metadata);\n    } else {\n      this.validationMetadatas.set(metadata.target, [metadata]);\n    }\n  }\n\n  /**\n   * Adds a new constraint metadata.\n   */\n  addConstraintMetadata(metadata: ConstraintMetadata): void {\n    const existingMetadata = this.constraintMetadatas.get(metadata.target);\n\n    if (existingMetadata) {\n      existingMetadata.push(metadata);\n    } else {\n      this.constraintMetadatas.set(metadata.target, [metadata]);\n    }\n  }\n\n  /**\n   * Groups metadata by their property names.\n   */\n  groupByPropertyName(metadata: ValidationMetadata[]): { [propertyName: string]: ValidationMetadata[] } {\n    const grouped: { [propertyName: string]: ValidationMetadata[] } = {};\n    metadata.forEach(metadata => {\n      if (!grouped[metadata.propertyName]) grouped[metadata.propertyName] = [];\n      grouped[metadata.propertyName].push(metadata);\n    });\n    return grouped;\n  }\n\n  /**\n   * Gets all validation metadatas for the given object with the given groups.\n   */\n  getTargetValidationMetadatas(\n    targetConstructor: Function,\n    targetSchema: string,\n    always: boolean,\n    strictGroups: boolean,\n    groups?: string[]\n  ): ValidationMetadata[] {\n    const includeMetadataBecauseOfAlwaysOption = (metadata: ValidationMetadata): boolean => {\n      // `metadata.always` overrides global default.\n      if (typeof metadata.always !== 'undefined') return metadata.always;\n\n      // `metadata.groups` overrides global default.\n      if (metadata.groups && metadata.groups.length) return false;\n\n      // Use global default.\n      return always;\n    };\n\n    const excludeMetadataBecauseOfStrictGroupsOption = (metadata: ValidationMetadata): boolean => {\n      if (strictGroups) {\n        // Validation is not using groups.\n        if (!groups || !groups.length) {\n          // `metadata.groups` has at least one group.\n          if (metadata.groups && metadata.groups.length) return true;\n        }\n      }\n\n      return false;\n    };\n\n    // get directly related to a target metadatas\n    const filteredForOriginalMetadatasSearch = this.validationMetadatas.get(targetConstructor) || [];\n    const originalMetadatas = filteredForOriginalMetadatasSearch.filter(metadata => {\n      if (metadata.target !== targetConstructor && metadata.target !== targetSchema) return false;\n      if (includeMetadataBecauseOfAlwaysOption(metadata)) return true;\n      if (excludeMetadataBecauseOfStrictGroupsOption(metadata)) return false;\n      if (groups && groups.length > 0)\n        return metadata.groups && !!metadata.groups.find(group => groups.indexOf(group) !== -1);\n\n      return true;\n    });\n\n    // get metadatas for inherited classes\n    const filteredForInheritedMetadatasSearch = [];\n    for (const [key, value] of this.validationMetadatas.entries()) {\n      if (targetConstructor.prototype instanceof key) {\n        filteredForInheritedMetadatasSearch.push(...value);\n      }\n    }\n    const inheritedMetadatas = filteredForInheritedMetadatasSearch.filter(metadata => {\n      // if target is a string it's means we validate against a schema, and there is no inheritance support for schemas\n      if (typeof metadata.target === 'string') return false;\n      if (metadata.target === targetConstructor) return false;\n      if (metadata.target instanceof Function && !(targetConstructor.prototype instanceof metadata.target))\n        return false;\n      if (includeMetadataBecauseOfAlwaysOption(metadata)) return true;\n      if (excludeMetadataBecauseOfStrictGroupsOption(metadata)) return false;\n      if (groups && groups.length > 0)\n        return metadata.groups && !!metadata.groups.find(group => groups.indexOf(group) !== -1);\n\n      return true;\n    });\n\n    // filter out duplicate metadatas, prefer original metadatas instead of inherited metadatas\n    const uniqueInheritedMetadatas = inheritedMetadatas.filter(inheritedMetadata => {\n      return !originalMetadatas.find(originalMetadata => {\n        return (\n          originalMetadata.propertyName === inheritedMetadata.propertyName &&\n          originalMetadata.type === inheritedMetadata.type\n        );\n      });\n    });\n\n    return originalMetadatas.concat(uniqueInheritedMetadatas);\n  }\n\n  /**\n   * Gets all validator constraints for the given object.\n   */\n  getTargetValidatorConstraints(target: Function): ConstraintMetadata[] {\n    return this.constraintMetadatas.get(target) || [];\n  }\n}\n\n/**\n * Gets metadata storage.\n * Metadata storage follows the best practices and stores metadata in a global variable.\n */\nexport function getMetadataStorage(): MetadataStorage {\n  const global = getGlobal();\n\n  if (!global.classValidatorMetadataStorage) {\n    global.classValidatorMetadataStorage = new MetadataStorage();\n  }\n\n  return global.classValidatorMetadataStorage;\n}\n","import { ValidationMetadataArgs } from './ValidationMetadataArgs';\nimport { ValidationArguments } from '../validation/ValidationArguments';\n\n/**\n * This metadata contains validation rules.\n */\nexport class ValidationMetadata {\n  // -------------------------------------------------------------------------\n  // Properties\n  // -------------------------------------------------------------------------\n\n  /**\n   * Validation type.\n   */\n  type: string;\n\n  /**\n   * Validator name.\n   */\n  name?: string;\n\n  /**\n   * Target class to which this validation is applied.\n   */\n  target: Function | string;\n\n  /**\n   * Property of the object to be validated.\n   */\n  propertyName: string;\n\n  /**\n   * Constraint class that performs validation. Used only for custom validations.\n   */\n  constraintCls: Function;\n\n  /**\n   * Array of constraints of this validation.\n   */\n  constraints: any[];\n\n  /**\n   * Validation message to be shown in the case of error.\n   */\n  message: string | ((args: ValidationArguments) => string);\n\n  /**\n   * Validation groups used for this validation.\n   */\n  groups: string[] = [];\n\n  /**\n   * Indicates if validation must be performed always, no matter of validation groups used.\n   */\n  always?: boolean;\n\n  /**\n   * Specifies if validated value is an array and each of its item must be validated.\n   */\n  each: boolean = false;\n\n  /*\n   * A transient set of data passed through to the validation result for response mapping\n   */\n  context?: any = undefined;\n\n  /**\n   * Extra options specific to validation type.\n   */\n  validationTypeOptions: any;\n\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n\n  constructor(args: ValidationMetadataArgs) {\n    this.type = args.type;\n    this.name = args.name;\n    this.target = args.target;\n    this.propertyName = args.propertyName;\n    this.constraints = args?.constraints;\n    this.constraintCls = args.constraintCls;\n    this.validationTypeOptions = args.validationTypeOptions;\n    if (args.validationOptions) {\n      this.message = args.validationOptions.message;\n      this.groups = args.validationOptions.groups;\n      this.always = args.validationOptions.always;\n      this.each = args.validationOptions.each;\n      this.context = args.validationOptions.context;\n    }\n  }\n}\n","/**\n * Validation types.\n */\nexport class ValidationTypes {\n  /* system */\n  static CUSTOM_VALIDATION = 'customValidation'; // done\n  static NESTED_VALIDATION = 'nestedValidation'; // done\n  static PROMISE_VALIDATION = 'promiseValidation'; // done\n  static CONDITIONAL_VALIDATION = 'conditionalValidation'; // done\n  static WHITELIST = 'whitelistValidation'; // done\n  static IS_DEFINED = 'isDefined'; // done\n\n  /**\n   * Checks if validation type is valid.\n   */\n  static isValid(type: string): boolean {\n    return (\n      type !== 'isValid' &&\n      type !== 'getMessage' &&\n      Object.keys(this)\n        .map(key => (this as any)[key])\n        .indexOf(type) !== -1\n    );\n  }\n}\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isFQDN;\n\nvar _assertString = _interopRequireDefault(require(\"./util/assertString\"));\n\nvar _merge = _interopRequireDefault(require(\"./util/merge\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar default_fqdn_options = {\n  require_tld: true,\n  allow_underscores: false,\n  allow_trailing_dot: false,\n  allow_numeric_tld: false,\n  allow_wildcard: false\n};\n\nfunction isFQDN(str, options) {\n  (0, _assertString.default)(str);\n  options = (0, _merge.default)(options, default_fqdn_options);\n  /* Remove the optional trailing dot before checking validity */\n\n  if (options.allow_trailing_dot && str[str.length - 1] === '.') {\n    str = str.substring(0, str.length - 1);\n  }\n  /* Remove the optional wildcard before checking validity */\n\n\n  if (options.allow_wildcard === true && str.indexOf('*.') === 0) {\n    str = str.substring(2);\n  }\n\n  var parts = str.split('.');\n  var tld = parts[parts.length - 1];\n\n  if (options.require_tld) {\n    // disallow fqdns without tld\n    if (parts.length < 2) {\n      return false;\n    }\n\n    if (!/^([a-z\\u00A1-\\u00A8\\u00AA-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]{2,}|xn[a-z0-9-]{2,})$/i.test(tld)) {\n      return false;\n    } // disallow spaces\n\n\n    if (/\\s/.test(tld)) {\n      return false;\n    }\n  } // reject numeric TLDs\n\n\n  if (!options.allow_numeric_tld && /^\\d+$/.test(tld)) {\n    return false;\n  }\n\n  return parts.every(function (part) {\n    if (part.length > 63) {\n      return false;\n    }\n\n    if (!/^[a-z_\\u00a1-\\uffff0-9-]+$/i.test(part)) {\n      return false;\n    } // disallow full-width chars\n\n\n    if (/[\\uff01-\\uff5e]/.test(part)) {\n      return false;\n    } // disallow parts starting or ending with hyphen\n\n\n    if (/^-|-$/.test(part)) {\n      return false;\n    }\n\n    if (!options.allow_underscores && /_/.test(part)) {\n      return false;\n    }\n\n    return true;\n  });\n}\n\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isIP;\n\nvar _assertString = _interopRequireDefault(require(\"./util/assertString\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n11.3.  Examples\n\n   The following addresses\n\n             fe80::1234 (on the 1st link of the node)\n             ff02::5678 (on the 5th link of the node)\n             ff08::9abc (on the 10th organization of the node)\n\n   would be represented as follows:\n\n             fe80::1234%1\n             ff02::5678%5\n             ff08::9abc%10\n\n   (Here we assume a natural translation from a zone index to the\n   <zone_id> part, where the Nth zone of any scope is translated into\n   \"N\".)\n\n   If we use interface names as <zone_id>, those addresses could also be\n   represented as follows:\n\n            fe80::1234%ne0\n            ff02::5678%pvc1.3\n            ff08::9abc%interface10\n\n   where the interface \"ne0\" belongs to the 1st link, \"pvc1.3\" belongs\n   to the 5th link, and \"interface10\" belongs to the 10th organization.\n * * */\nvar IPv4SegmentFormat = '(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])';\nvar IPv4AddressFormat = \"(\".concat(IPv4SegmentFormat, \"[.]){3}\").concat(IPv4SegmentFormat);\nvar IPv4AddressRegExp = new RegExp(\"^\".concat(IPv4AddressFormat, \"$\"));\nvar IPv6SegmentFormat = '(?:[0-9a-fA-F]{1,4})';\nvar IPv6AddressRegExp = new RegExp('^(' + \"(?:\".concat(IPv6SegmentFormat, \":){7}(?:\").concat(IPv6SegmentFormat, \"|:)|\") + \"(?:\".concat(IPv6SegmentFormat, \":){6}(?:\").concat(IPv4AddressFormat, \"|:\").concat(IPv6SegmentFormat, \"|:)|\") + \"(?:\".concat(IPv6SegmentFormat, \":){5}(?::\").concat(IPv4AddressFormat, \"|(:\").concat(IPv6SegmentFormat, \"){1,2}|:)|\") + \"(?:\".concat(IPv6SegmentFormat, \":){4}(?:(:\").concat(IPv6SegmentFormat, \"){0,1}:\").concat(IPv4AddressFormat, \"|(:\").concat(IPv6SegmentFormat, \"){1,3}|:)|\") + \"(?:\".concat(IPv6SegmentFormat, \":){3}(?:(:\").concat(IPv6SegmentFormat, \"){0,2}:\").concat(IPv4AddressFormat, \"|(:\").concat(IPv6SegmentFormat, \"){1,4}|:)|\") + \"(?:\".concat(IPv6SegmentFormat, \":){2}(?:(:\").concat(IPv6SegmentFormat, \"){0,3}:\").concat(IPv4AddressFormat, \"|(:\").concat(IPv6SegmentFormat, \"){1,5}|:)|\") + \"(?:\".concat(IPv6SegmentFormat, \":){1}(?:(:\").concat(IPv6SegmentFormat, \"){0,4}:\").concat(IPv4AddressFormat, \"|(:\").concat(IPv6SegmentFormat, \"){1,6}|:)|\") + \"(?::((?::\".concat(IPv6SegmentFormat, \"){0,5}:\").concat(IPv4AddressFormat, \"|(?::\").concat(IPv6SegmentFormat, \"){1,7}|:))\") + ')(%[0-9a-zA-Z-.:]{1,})?$');\n\nfunction isIP(str) {\n  var version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  (0, _assertString.default)(str);\n  version = String(version);\n\n  if (!version) {\n    return isIP(str, 4) || isIP(str, 6);\n  }\n\n  if (version === '4') {\n    if (!IPv4AddressRegExp.test(str)) {\n      return false;\n    }\n\n    var parts = str.split('.').sort(function (a, b) {\n      return a - b;\n    });\n    return parts[3] <= 255;\n  }\n\n  if (version === '6') {\n    return !!IPv6AddressRegExp.test(str);\n  }\n\n  return false;\n}\n\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isURL;\n\nvar _assertString = _interopRequireDefault(require(\"./util/assertString\"));\n\nvar _isFQDN = _interopRequireDefault(require(\"./isFQDN\"));\n\nvar _isIP = _interopRequireDefault(require(\"./isIP\"));\n\nvar _merge = _interopRequireDefault(require(\"./util/merge\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n/*\noptions for isURL method\n\nrequire_protocol - if set as true isURL will return false if protocol is not present in the URL\nrequire_valid_protocol - isURL will check if the URL's protocol is present in the protocols option\nprotocols - valid protocols can be modified with this option\nrequire_host - if set as false isURL will not check if host is present in the URL\nrequire_port - if set as true isURL will check if port is present in the URL\nallow_protocol_relative_urls - if set as true protocol relative URLs will be allowed\nvalidate_length - if set as false isURL will skip string length validation (IE maximum is 2083)\n\n*/\nvar default_url_options = {\n  protocols: ['http', 'https', 'ftp'],\n  require_tld: true,\n  require_protocol: false,\n  require_host: true,\n  require_port: false,\n  require_valid_protocol: true,\n  allow_underscores: false,\n  allow_trailing_dot: false,\n  allow_protocol_relative_urls: false,\n  allow_fragments: true,\n  allow_query_components: true,\n  validate_length: true\n};\nvar wrapped_ipv6 = /^\\[([^\\]]+)\\](?::([0-9]+))?$/;\n\nfunction isRegExp(obj) {\n  return Object.prototype.toString.call(obj) === '[object RegExp]';\n}\n\nfunction checkHost(host, matches) {\n  for (var i = 0; i < matches.length; i++) {\n    var match = matches[i];\n\n    if (host === match || isRegExp(match) && match.test(host)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction isURL(url, options) {\n  (0, _assertString.default)(url);\n\n  if (!url || /[\\s<>]/.test(url)) {\n    return false;\n  }\n\n  if (url.indexOf('mailto:') === 0) {\n    return false;\n  }\n\n  options = (0, _merge.default)(options, default_url_options);\n\n  if (options.validate_length && url.length >= 2083) {\n    return false;\n  }\n\n  if (!options.allow_fragments && url.includes('#')) {\n    return false;\n  }\n\n  if (!options.allow_query_components && (url.includes('?') || url.includes('&'))) {\n    return false;\n  }\n\n  var protocol, auth, host, hostname, port, port_str, split, ipv6;\n  split = url.split('#');\n  url = split.shift();\n  split = url.split('?');\n  url = split.shift();\n  split = url.split('://');\n\n  if (split.length > 1) {\n    protocol = split.shift().toLowerCase();\n\n    if (options.require_valid_protocol && options.protocols.indexOf(protocol) === -1) {\n      return false;\n    }\n  } else if (options.require_protocol) {\n    return false;\n  } else if (url.substr(0, 2) === '//') {\n    if (!options.allow_protocol_relative_urls) {\n      return false;\n    }\n\n    split[0] = url.substr(2);\n  }\n\n  url = split.join('://');\n\n  if (url === '') {\n    return false;\n  }\n\n  split = url.split('/');\n  url = split.shift();\n\n  if (url === '' && !options.require_host) {\n    return true;\n  }\n\n  split = url.split('@');\n\n  if (split.length > 1) {\n    if (options.disallow_auth) {\n      return false;\n    }\n\n    if (split[0] === '') {\n      return false;\n    }\n\n    auth = split.shift();\n\n    if (auth.indexOf(':') >= 0 && auth.split(':').length > 2) {\n      return false;\n    }\n\n    var _auth$split = auth.split(':'),\n        _auth$split2 = _slicedToArray(_auth$split, 2),\n        user = _auth$split2[0],\n        password = _auth$split2[1];\n\n    if (user === '' && password === '') {\n      return false;\n    }\n  }\n\n  hostname = split.join('@');\n  port_str = null;\n  ipv6 = null;\n  var ipv6_match = hostname.match(wrapped_ipv6);\n\n  if (ipv6_match) {\n    host = '';\n    ipv6 = ipv6_match[1];\n    port_str = ipv6_match[2] || null;\n  } else {\n    split = hostname.split(':');\n    host = split.shift();\n\n    if (split.length) {\n      port_str = split.join(':');\n    }\n  }\n\n  if (port_str !== null && port_str.length > 0) {\n    port = parseInt(port_str, 10);\n\n    if (!/^[0-9]+$/.test(port_str) || port <= 0 || port > 65535) {\n      return false;\n    }\n  } else if (options.require_port) {\n    return false;\n  }\n\n  if (options.host_whitelist) {\n    return checkHost(host, options.host_whitelist);\n  }\n\n  if (!(0, _isIP.default)(host) && !(0, _isFQDN.default)(host, options) && (!ipv6 || !(0, _isIP.default)(ipv6, 6))) {\n    return false;\n  }\n\n  host = host || ipv6;\n\n  if (options.host_blacklist && checkHost(host, options.host_blacklist)) {\n    return false;\n  }\n\n  return true;\n}\n\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = assertString;\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction assertString(input) {\n  var isString = typeof input === 'string' || input instanceof String;\n\n  if (!isString) {\n    var invalidType = _typeof(input);\n\n    if (input === null) invalidType = 'null';else if (invalidType === 'object') invalidType = input.constructor.name;\n    throw new TypeError(\"Expected a string but received a \".concat(invalidType));\n  }\n}\n\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = merge;\n\nfunction merge() {\n  var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var defaults = arguments.length > 1 ? arguments[1] : undefined;\n\n  for (var key in defaults) {\n    if (typeof obj[key] === 'undefined') {\n      obj[key] = defaults[key];\n    }\n  }\n\n  return obj;\n}\n\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","export default function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {\n  var desc = {};\n  Object.keys(descriptor).forEach(function (key) {\n    desc[key] = descriptor[key];\n  });\n  desc.enumerable = !!desc.enumerable;\n  desc.configurable = !!desc.configurable;\n  if ('value' in desc || desc.initializer) {\n    desc.writable = true;\n  }\n  desc = decorators.slice().reverse().reduce(function (desc, decorator) {\n    return decorator(target, property, desc) || desc;\n  }, desc);\n  if (context && desc.initializer !== void 0) {\n    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;\n    desc.initializer = undefined;\n  }\n  if (desc.initializer === void 0) {\n    Object.defineProperty(target, property, desc);\n    desc = null;\n  }\n  return desc;\n}","export default function _initializerDefineProperty(target, property, descriptor, context) {\n  if (!descriptor) return;\n  Object.defineProperty(target, property, {\n    enumerable: descriptor.enumerable,\n    configurable: descriptor.configurable,\n    writable: descriptor.writable,\n    value: descriptor.initializer ? descriptor.initializer.call(context) : void 0\n  });\n}"],"names":["Type","typeFunction","options","target","propertyName","reflectedType","Reflect","getMetadata","defaultMetadataStorage","constructor","TransformationType","transformationType","recursionStack","Set","TransformOperationExecutor","source","value","targetType","arrayType","isMap","level","p","Array","isArray","newValue_1","this","array","instantiateArrayType","forEach","subValue","index","subSource","undefined","_this","enableCircularCheck","isCircular","add","push","realTargetType","discriminator","property","subTypes","find","subType","name","newObject","object","newType","keepDiscriminatorProperty","value_1","transform","Map","String","Number","Boolean","Date","valueOf","globalThis","global","window","self","Buffer","from","then","Object","keys","getKeys","newValue","key","valueKey","newValueKey","this_1","ignoreDecorators","exposeMetadata","get","Function","type","isSubValueMap","metadata_1","targetMaps","filter","map","properties","enableImplicitConversion","prototype","arrayType_1","getReflectedType","descriptor","getOwnPropertyDescriptor","set","finalValue","applyCustomTransformations","exposeUnsetFields","transformKey","exposeDefaultValues","keys_1","_i","delete","Promise","resolve","reject","data","obj","metadatas","version","metadata","checkVersion","since","until","groups","length","checkGroups","transformFn","has","meta","strategy","excludeExtraneousValues","exposedProperties","excludedProperties","concat","excludedProperties_1","includes","excludePrefixes","every","prefix","substr","indexOf","decision","some","optionGroup","defaultOptions","classTransformer","ClassTransformer","plainObject","cls","plain","clsObject","fromObject","JSON","stringify","instanceToPlain","json","jsonObject","parse","plainToInstance","_typeMetadatas","_transformMetadatas","_exposeMetadatas","_excludeMetadatas","_ancestorsMap","MetadataStorage","findMetadatas","toClassOnly","toPlainOnly","findMetadata","getExposedMetadatas","excludeMap","exclude","exposeMap","expose","getExcludedMetadatas","clear","metadataFromTarget","metadataFromTargetMap","values","metadataFromAncestors","_a","getAncestors","ancestor","ancestorMetadataMap","metadataFromAncestor","ancestorResult","metadataFromAncestorsTarget","slice","reverse","ancestors","baseClass","getPrototypeOf","userContainer","userContainerOptions","defaultContainer","instances","class_1","someClass","instance","getFromContainer","fallback","error","fallbackOnErrors","IS_DEFINED","ValidationTypes","IsDefined","validationOptions","ValidateBy","validator","validate","isDefined","defaultMessage","buildMessage","eachPrefix","async","ConstraintMetadata","impl","validationArguments","each","constraintCls","getTargetValidatorConstraints","validator_1","CustomConstraint","getMetadataStorage","addConstraintMetadata","validationMetadataArgs","constraints","addValidationMetadata","ValidationMetadata","registerDecorator","ValidateNested","opts","message","args","IsUrl","isUrlValidator","isURL","IsArray","IsString","isString","ValidationError","shouldDecorate","hasParent","parentPath","showConstraintMessages","boldStart","boldEnd","propConstraintFailed","join","constraintsToString","formattedProperty_1","isInteger","children","childError","toString","ValidationUtils","messageString","constraint","replace","RegExp","description","constraintToString","targetName","isPromise","validatorOptions","awaitingPromises","ignoreAsyncValidations","metadataStorage","ValidationExecutor","targetSchema","validationErrors","hasValidationMetaData","enableDebugMessages","console","warn","strictGroups","always","forbidUnknownValues","targetMetadatas","getTargetValidationMetadatas","groupedMetadatas","groupByPropertyName","validationError","unknownValue","whitelist","definedMetadatas","resolvedValue","performValidations","notAllowedProperties","forbidNonWhitelisted","generateValidationError","errors","stripEmptyErrors","customValidationMetadatas","nestedValidationMetadatas","conditionalValidationMetadatas","conditionalValidations","customValidations","mapContexts","skipUndefinedProperties","skipNullProperties","skipMissingProperties","nestedValidations","reduce","resultA","resultB","customConstraintMetadata","stopAtFirstError","val","validatedSubValues","validatedSubValue","asyncValidatedSubValues","asyncValidationIsFinishedPromise","all","flatValidatedValues","isValid","createValidationError","context","contexts","assign","validatedValue","promise","execute","customConstraint","getConstraintType","customValidatorMetadata","dismissDefaultMessages","replaceMessageSpecialTokens","Validator","objectOrSchemaName","objectOrValidationOptions","maybeValidatorOptions","coreValidate","schema","executor","validateOrReject","schemaNameOrObject","ValidationSchemaToMetadataTransformer","validation","validationTypeOptions","validationMetadatas","constraintMetadatas","size","validationMetadata","existingMetadata","grouped","targetConstructor","includeMetadataBecauseOfAlwaysOption","excludeMetadataBecauseOfStrictGroupsOption","originalMetadatas","group","filteredForInheritedMetadatasSearch","entries","uniqueInheritedMetadatas","inheritedMetadata","originalMetadata","classValidatorMetadataStorage","defineProperty","exports","str","_assertString","default","_merge","default_fqdn_options","allow_trailing_dot","substring","allow_wildcard","parts","split","tld","require_tld","test","allow_numeric_tld","part","allow_underscores","_interopRequireDefault","require","__esModule","module","isIP","arguments","IPv4AddressRegExp","sort","a","b","IPv6AddressRegExp","IPv4SegmentFormat","IPv4AddressFormat","IPv6SegmentFormat","url","default_url_options","validate_length","allow_fragments","allow_query_components","protocol","auth","host","hostname","port","port_str","ipv6","shift","toLowerCase","require_valid_protocol","protocols","require_protocol","allow_protocol_relative_urls","require_host","disallow_auth","_auth$split","_auth$split2","i","arr","_arrayWithHoles","Symbol","iterator","_arr","_n","_d","_e","_s","next","done","err","_iterableToArrayLimit","o","minLen","_arrayLikeToArray","n","call","_unsupportedIterableToArray","TypeError","_nonIterableRest","user","password","ipv6_match","match","wrapped_ipv6","parseInt","require_port","host_whitelist","checkHost","_isIP","_isFQDN","host_blacklist","len","arr2","matches","_typeof","input","invalidType","defaults","_applyDecoratedDescriptor","decorators","desc","enumerable","configurable","initializer","writable","decorator","_initializerDefineProperty"],"sourceRoot":""}